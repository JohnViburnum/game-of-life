//****************************************************************************************************************************************
//БЛОК НАЧАЛЬНЫХ ЗНАЧЕНИЙ И ФУНКЦИЙ

//Генерация 2-мерного массива для координат клеток
let cells1 = []; //- массив для координат предыдущего поколения клеток
let cells2 = []; //- массив для координат последующего поколения клеток

function genCoordinates() { //----------- функция генерации координат и присвоение им 0
  for (let i = -1; i <= 500; i++) { //--- цикл генерации координат от -1 (для реализации ограниченного мира) до 500
    cells1[i] = []; //------------------- генерация массива X-координат предыдущего поколения
    cells2[i] = []; //------------------- генерация массива X-координат последующего поколения
    for (let j = -1; j <= 500; j++) { //- цикл генерации массивов для Y-координат в X-координате
      cells1[i][j] = 0; //--------------- генерация массивов в массиве и присвоение 0
      cells2[i][j] = 0; //--------------- генерация массивов в массиве и присвоение 0
    }
  }
}

genCoordinates(); //- запуск функции генерации координат и присвоения им 0

//Основной канвас
const canvas = document.querySelector('#canvas'); //--- канвас
const ctx = canvas.getContext('2d'); //---------------- 2D контекст канвас
const inptCnW = document.querySelector('#inptCnW'); //- селект количества ячеек ширины
const inptCnH = document.querySelector('#inptCnH'); //- селект количества ячеек высоты

let cW = inptCnW.value; //- переменная количества ячеек ширины
let cH = inptCnH.value; //- переменная количества ячеек высоты
let cellSize = 10; //------ размер клетки (начальное значение)
let step = true; //-------- переменная смены поколений: (true - предыдущее поколение, false - последующее)
let trackMode = false; //-- переменная режима следов (true - активирован, false - деактивирован)
let worldEnd = false; //--- переменная режима границ мира (false - мир замкнут на себя, true - мир ограничен)

let width = canvas.width = cW * cellSize; //--- ширина канвас количество ячеек ширины * размер клетки
let height = canvas.height = cH * cellSize; //- высота канвас количество ячеек высоты * размер клетки

//Функции отрисовки основного канвас
const colonyColor = document.querySelector('#colonyColor'); //- поле ввода цвета колонии
const emptyColor = document.querySelector('#emptyColor'); //--- поле ввода цвета фона
const trackColor = document.querySelector('#trackColor'); //--- поле ввода цвета фона в режиме следов

function drawBackground() { //---------- функция стартовой отрисовки канвас
  ctx.fillStyle = 'lightgray'; //------- цвет отрисовки светлосерый, для отображения сетки
  ctx.fillRect(0, 0, width, height); //- отрисовка всего поля
}
function life(x, y) { //--------------------------------------------------- функция отрисовки живых клеток
  ctx.fillStyle = colonyColor.value; //------------------------------------ цвет отрисовки присваивает значение поля выбора цвета
  ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1); //- координаты отрисовки, ширина и высота клетки
}
function empty(x, y) { //-------------------------------------------------- функция отрисовки пустых клеток
  ctx.fillStyle = emptyColor.value; //------------------------------------- цвет отрисовки присваивает значение поля выбора цвета
  ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1); //- координаты отрисовки, ширина и высота клетки
}
function shadow(x, y) { //------------------------------------------------- функция отрисовки тени пользовательской колонии
  ctx.fillStyle = 'lightgray'; //------------------------------------------ цвет отрисовки светлосерый
  ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1); //- координаты отрисовки, ширина и высота клетки
}
function track(x, y) { //-------------------------------------------------- функция отрисовки полотна для отслеживания следа
  ctx.fillStyle = trackColor.value; //------------------------------------- цвет отрисовки присваивает значение поля выбора цвета
  ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1); //- координаты отрисовки, ширина и высота клетки
}

function drawCells() { //------------ функция отрисовки клеток
  for (let i = 0; i < cW; i++) { //-- цикл перебора всех координат
    for (let j = 0; j < cH; j++) {
      if (step) { //----------------- если предыдущее поколение
        if (cells1[i][j] === 1) { //- если координаты клетки предыдущего поколения === 1, то
          life(i, j); //------------- запуск функции отрисовки живых клеток
        } else { //------------------ иначе (если координаты === 0)
          if (trackMode) { //-------- если режим следов активирован, то
            track(i, j); //---------- запуск отрисовки темного фона
          } else { //---------------- иначе (если режим следов деактивирован), то
            empty(i, j); //---------- запуск отрисовки пустых клеток
          }
        }
      } else { //-------------------- иначе (если последующее поколение), то (аналогично для последующего поколения)
        if (cells2[i][j] === 1) {
          life(i, j);
        } else {
          if (trackMode) {
            track(i, j);
          } else {
            empty(i, j);
          }
        }
      }
    }
  }
}

//Отображение поколений клеток
const textCount = document.querySelector('#textCount'); //------- текст счета поколений
const lifeRule = document.querySelector('#lifeRule'); //--------- поле ввода константы зарождения клетки
const deathRuleMin = document.querySelector('#deathRuleMin'); //- поле ввода минимальной константы сохранения жизни клетки
const deathRuleMax = document.querySelector('#deathRuleMax'); //- поле ввода максимальной константы сохранения жизни клетки

let count = 0; //- переменная счетчика поколений

function generation(a, b) { //------ функция для отображения поколения (a - клетки предыдущего поколения, b - клетки последующего поколения)
  for (let i = 0; i < cW; i++) { //- цикл перебора массива массивов
    for (let j = 0; j < cH; j++) {
      let nbrs = 0; //------------------------------------ переменная клеток-соседей
      if (a[xsw(i) - 1][xsh(j) - 1] === 1) { nbrs++ }; //- если у клетки в положении -1 по X -1 по Y есть клетка, то nbrs + 1
      if (a[xsw(i) - 1][j] === 1) { nbrs++ }; //---------- аналогично, но с изменением положения клетки-соседки
      if (a[xsw(i) - 1][xlh(j) + 1] === 1) { nbrs++ };
      if (a[i][xsh(j) - 1] === 1) { nbrs++ };
      if (a[i][xlh(j) + 1] === 1) { nbrs++ };
      if (a[xlw(i) + 1][xsh(j) - 1] === 1) { nbrs++ };
      if (a[xlw(i) + 1][j] === 1) { nbrs++ };
      if (a[xlw(i) + 1][xlh(j) + 1] === 1) { nbrs++ };

      //блок правил для жизни клеток
      if (a[i][j] === 0) { //--------------------- если клетка пуста в предыдущем поколении, то
        if (nbrs === Number(lifeRule.value)) { //- если количество соседей равно значению поля ввода константы зарождения жизни клетки , то
          b[i][j] = 1; //------------------------- клетка появляется в последующем поколении
          life(i, j); //-------------------------- запуск отрисовки живых клеток
        }
      } else { //----------------------------------- иначе (если клетка жива)
        if (nbrs < Number(deathRuleMin.value) || //- если количестов соседей меньше значения поля ввода минимальной константы сохранения жизни клетки ИЛИ
          nbrs > Number(deathRuleMax.value)) { //--- больше значения поля ввода максимальной константы сохранения жизни клетки
          b[i][j] = 0; //--------------------------- клетка исчезает в последующем поколении
          empty(i, j); //--------------------------- запуск отрисовки пустых клеток
        } else { //--------------------------------- иначе (если количество соседей равно 2 или 3), то
          b[i][j] = 1; //--------------------------- клетка сохраняется в последующем поколении
          life(i, j); //---------------------------- запуск отрисовки живых клеток
        }
      }
    }
  }
  for (let i = 0; i < cW; i++) { //- цикл очистки предыдущего поколения
    for (let j = 0; j < cH; j++) {
      a[i][j] = 0;
    }
  }
  count++; //--------------------------------------- счет +1
  textCount.textContent = `Поколение: ${count}`; //- текст подписи счетчика поколений
}

//блок функций границ мира
function xlh(c) { //------- функция для ограничения мира снизу
  if (!worldEnd) { //------ если мир замкнут на себя, то
    if (c === cH - 1) { //- если координата равна количеству ячеек высоты - 1, то
      c = -1; //----------- координате присваиваится -1
    }
    return c; //------- возврат координаты
  } else { //---------- иначе (если мир ограничен)
    if (c === cH) { //- если координата равна количеству ячеек высоты, то
      c = cH - 2; //--- координате присваиватся количество ячеек высоты - 2
    }
    return c; //- возврат координаты
  }
}
function xlw(c) { //- функция для ограничения мира справа (аналогично, но с ячейками ширины)
  if (!worldEnd) {
    if (c === cW - 1) {
      c = -1;
    }
    return c;
  } else {
    if (c === cW) {
      c = cW - 2;
    }
    return c;
  }
}
function xsh(c) { //-- функция для ограничения мира сверху
  if (!worldEnd) { //- если мир замкнут на себя, то
    if (c === 0) { //- если координата равна 0, то
      c = cH; //------ координате присваивается количество ячеек высоты
    }
    return c; //------- возврат координаты
  } else { //---------- иначе (если мир ограничен)
    if (c === -1) { //- если координата равна -1, то
      c = 1; //-------- координате присваивается 1
    }
    return c; //- возврат координаты
  }
}
function xsw(c) { //- функция для ограничения мира слева (аналогично, но с ячейками ширины)
  if (!worldEnd) {
    if (c === 0) {
      c = cW;
    }
    return c;
  } else {
    if (c === -1) {
      c = 1;
    }
    return c;
  }
}

//****************************************************************************************************************************************
//БЛОК НАСТРОЕК

//Старт
const btnStartStop = document.querySelector('#btnStartStop'); //- кнопка старт/стоп
const slctGenSpeed = document.querySelector('#slctGenSpeed'); //- селект скорости смены колоний

let start = false; //- переменная старта автоматической смены колоний
let interval; //------ переменная интервала для скорости смены колоний

btnStartStop.addEventListener('click', startStopGame);  //- при нажатии на кнопку: старт/стоп

function startStopGame() { //------------------ функция старт/стоп
  if (start) { //------------------------------ если старт активирован, то
    start = false; //-------------------------- старт деактивирован
    btnStartStop.classList.remove('start'); //- удаление класса start для кнопки старта/паузы
    btnStartStop.classList.add('stop'); //----- добавление класса stop для кнопки старта/паузы
    clearInterval(interval); //---------------- очиста интервала запуска фунции смены поколений
  } else { //---------------------------------- иначе (если старт деактивирован, то) (аналогично)
    start = true;
    btnStartStop.classList.add('start');
    btnStartStop.classList.remove('stop');
    interval = setInterval(genСhange, slctGenSpeed.value); //- назначение временного интервала запуска функции смены поколений
  }
}

//Скорость смены поколений 
slctGenSpeed.addEventListener('change', speedGenСhange); //- при изменнении значения селектора: изменение скорости смены поколений

function speedGenСhange() { //-------------------------------- функция изменения скорости смены поколений
  if (start) { //--------------------------------------------- если старт активирован, то
    clearInterval(interval); //------------------------------- очистка интервала
    interval = setInterval(genСhange, slctGenSpeed.value); //- назначение интервала для функции смены поколений
  }
}

//Один шаг
const btnOneStep = document.querySelector('#btnOneStep'); //- кнопка одного шага игры

btnOneStep.addEventListener('click', oneStepGame); //- при нажатии: один шаг игры

function oneStepGame() { //-------------------- функция одного шага игры
  if (start) { //------------------------------ если старт активирован, то
    start = false; //-------------------------- старт деактивирован
    btnStartStop.classList.remove('start'); //- удаление класса start для кнопки старта/паузы
    btnStartStop.classList.add('stop'); //----- добавление класса stop для кнопки старта/паузы
    clearInterval(interval); //---------------- очиста интервала запуска фунции смены поколений
  }
  genСhange(); //- запуск функции смены поколений
}

function genСhange() { //---------- функция смены поколений
  if (step) { //------------------- если предыдущее поколение, то
    generation(cells1, cells2); //- запуск функции для отображения поколений (предыдущее поколение - cells1, последующее - cells2)
    step = false; //--------------- последующее поколение
  } else { //---------------------- иначе, (если последующее поколение)
    generation(cells2, cells1); //- запуск функции для отображения поколений (предыдущее поколение - cells2, последующее - cells1)
    step = true; //---------------- предыдущее поколение
  }
}

//Очистка мира
const btnClear = document.querySelector('#btnClear') //- кнопка очистки мира

btnClear.addEventListener('click', clearGame); //- при нажатии кнопки: очистка мира

function clearGame() { //---------------------------- функция очистки мира
  genCoordinates(); //------------------------------- запуск функции генерации координат и присвоение им 0
  drawBackground(); //------------------------------- запуск функции стартовой отрисовки канвас
  drawCells(); //------------------------------------ запуск функции отрисовки клеток
  step = true; //------------------------------------ присваивание предыдущего поколения для переменной шага
  start = false; //---------------------------------- деактивировация режима старта
  btnStartStop.classList.remove('start'); //--------- удаление класса start для кнопки старта/паузы
  btnStartStop.classList.add('stop'); //------------- добавление класса stop для кнопки старта/паузы
  count = 0; //-------------------------------------- сброс счетчика поколений
  textCount.textContent = `Поколение: ${count}`; //-- текст подписи счетчика поколений
  clearInterval(interval); //------------------------ очиста интервал запуска фунции смены поколений
  btnSaveClipboard.disabled = true; //--------------- отключение кнопки копирования строки координат в буфер обмена
  textStr.textContent = ''; //----------------------- обновление текста строки координат
  lengthArr.textContent = `Количество клеток: 0`; //- обновление текст количества координат
  lengthStr.textContent = `Длина строки: 0`; //------ обновление текста длины строки координат
}

//Масштаб
const btnScaleLarger = document.querySelector('#btnScaleLarger'); //--- кнопка увеличения масштаба
const btnScaleSmaller = document.querySelector('#btnScaleSmaller'); //- кнопка уменьшения масштаба

btnScaleLarger.addEventListener('click', scaleLarger); //--- при нажатии: увеличение масштаба
btnScaleSmaller.addEventListener('click', scaleSmaller); //- при нажатии: уменьшение масштаба

function scaleLarger() { //-------------- функция увеличения масштаба
  if (cellSize === 2) { //--------------- если размер клеток равен 2, то
    width = canvas.width *= 2.5; //------ ширина присваивает ширину умноженную на 2,5
    height = canvas.height *= 2.5; //---- высота присваивает ширину умноженную на 2,5
    cellSize = 5; //--------------------- размер клеток присваивает 5
    btnScaleSmaller.disabled = false; //- кнопка уменьшения масштаба выключена
  } else if (cellSize === 5) { //-------- иначе если размер клеток равен 5, то
    width = canvas.width *= 2; //-------- ширина присваивает ширину умноженную на 2
    height = canvas.height *= 2; //------ высота присваивает ширину умноженную на 2
    cellSize = 10; //-------------------- размер клеток присваивает 10
  } else if (cellSize === 10) { //------- иначе если  размер клеток равен 10, то
    width = canvas.width *= 2; //-------- ширина присваивает ширину умноженную на 2
    height = canvas.height *= 2; //------ высота присваивает ширину умноженную на 2
    cellSize = 20; //-------------------- размер клеток присваивает 20
    btnScaleLarger.disabled = true; //--- кнопка увеличения масштаба выключена
  }
  drawBackground(); //--- запуск функции стартовой отрисовки канвас
  drawCells(); //-------- запуск функции отрисовки клеток
  cW = inptCnW.value; //- обновление переменной количества ячеек ширины
  cH = inptCnH.value; //- обновление переменной количества ячеек высоты
}

function scaleSmaller() { //- функция уменьшения масштаба (аналогично)
  if (cellSize === 20) {
    width = canvas.width /= 2;
    height = canvas.height /= 2;
    cellSize = 10;
    btnScaleLarger.disabled = false;
  } else if (cellSize === 10) {
    width = canvas.width /= 2;
    height = canvas.height /= 2;
    cellSize = 5;
  } else if (cellSize === 5) {
    width = canvas.width /= 2.5;
    height = canvas.height /= 2.5;
    cellSize = 2;
    btnScaleSmaller.disabled = true;
  }
  drawBackground();
  drawCells();
  cW = inptCnW.value;
  cH = inptCnH.value;
}

//Режим границ мира
const btnLimitedWorld = document.querySelector('#btnLimitedWorld'); //- кнопка смены режима границ мира

btnLimitedWorld.addEventListener('click', limitedWorld); //- при нажатии: смена режима границ мира

function limitedWorld() { //--------------------------------- функция смены режима границ мира
  if (!worldEnd) { //---------------------------------------- если мир замкнут на себя, то
    worldEnd = true; //-------------------------------------- мир ограничен
    btnLimitedWorld.textContent = 'Замкнуть мир на себя'; //- обновление текста кнопки
    canvas.classList.add('border'); //----------------------- добавление класса 'border' для канвас
  } else { //------------------------------------------------ иначе (если мир ограничен), то (аналогично)
    worldEnd = false;
    btnLimitedWorld.textContent = 'Ограничить мир';
    canvas.classList.remove('border');
  }
  drawBackground(); //- запуск функции стартовой отрисовки канвас
  drawCells(); //------ запуск функции отрисовки клеток
}

//Режим следов
const btnTrackMode = document.querySelector('#btnTrackMode'); //- кнопка смены режима следов

btnTrackMode.addEventListener('click', trackModeFunc); //- при нажатии на кнопку: смена режима следов

function trackModeFunc() { //------------------------------ функция смены режима следов
  if (trackMode) { //-------------------------------------- если режим следов активирован, то
    trackMode = false; //---------------------------------- режим следов деактивирован
    drawCells(); //---------------------------------------- запуск функции отрисовки клеток
    btnTrackMode.textContent = 'Включить режим следов'; //- текст кнопки
  } else { //---------------------------------------------- иначе (если режим следов деактивирован), то (аналогично)
    trackMode = true;
    drawCells();
    btnTrackMode.textContent = 'Выключить режим следов';
  }
}

//Константы эволюции
const inptsLifeConstants = document.querySelectorAll('.inpt_life-constants'); //- поля ввода констант правил жизни

inptsLifeConstants.forEach(e => { //----------- для каждого поля ввода констант правил жизни
  e.addEventListener('input', () => { //------- при вводе
    if (e.validity.rangeOverflow) { //--------- если введено больше заданного правила (8), то
      e.value = 8; //-------------------------- значение поля ввода принимает 8
    } else if (e.validity.rangeUnderflow) { //- если введено меньше заданного правила (1), то
      e.value = 1; //-------------------------- значение поля ввода принимает 1
    }
  });
});

//Изменение размера мира
inptCnW.addEventListener('input', newWorld); //- при вводе: изменение размеров мира по ширине
inptCnH.addEventListener('input', newWorld); //- при вводе: изменение размеров мира по высоте

function newWorld() { //------------------------------ функция изменения размеров мира
  if (inptCnW.validity.rangeOverflow || //------------ если в поле ввода ширины введено более 500 ИЛИ
    inptCnH.validity.rangeOverflow) { //-------------- в поле ввода высоты введено более 500, то
    if (dataWarning.inputSizeMore500 === 'noOk') { //- если ввод размера мира более 500 клеток содержит noOk, то
      dWkey = 'inputSizeMore500';  //----------------- обновление ключа для объекта информационного окна
      let code =
        `<p>Ширина или высота мира не может быть более 500 клеток!<br />
        Введите меньшее число</p>`; //- текст информационного окна
      showWarning(code); //------------ запуск функции показа информационного окна
    }
  }
  if (inptCnW.validity.rangeOverflow) { //- если в поле ввода ширины введено более 500, то
    inptCnW.value = 500; //---------------- значение поля ввода ширины принимает 500 
  }
  if (inptCnH.validity.rangeOverflow) { //- если в поле ввода высоты введено более 500, то
    inptCnH.value = 500; //---------------- значение поля ввода высоты принимает 500 
  }
  if (inptCnW.validity.rangeUnderflow || //--------- если в поле ввода ширины введено менее 1 ИЛИ
    inptCnH.validity.rangeUnderflow) { //----------- в поле ввода высоты введено менее 1, то
    if (dataWarning.inputSizeLess1 === 'noOk') { //- если ввод размера мира менее 1 клетки содержит noOk, то
      dWkey = 'inputSizeLess1'  //------------------ обновление ключа для объекта типов информационного окна
      let code =
        `<p>Количество клеток не может быть нулевым или отрицательным</p>` //- текст информационного окна
      showWarning(code); //--------------------------------------------------- запуск функции показа информационного окна
    }
  }
  if (inptCnW.validity.rangeUnderflow) { //- если в поле ввода ширины введено менее 1, то
    inptCnW.value = 1; //------------------- значение поля ввода ширины принимает 1
  }
  if (inptCnH.validity.rangeUnderflow) { //- если в поле ввода высоты введено менее 1, то
    inptCnH.value = 1; //------------------- значение поля ввода высоты принимает 1
  }
  if (inptCnW.value % 1 !== 0 || //---------------- если в поле ввода ширины введено число не делящееся на 1 без остатка (дробь), ИЛИ
    inptCnH.value % 1 !== 0) { //------------------ в поле ввода высоты введено число не делящееся на 1 без остатка, то
    if (dataWarning.inputSizeFrac === 'noOk') { //- если ввод размера мира дробным числом содержит noOk, то
      dWkey = 'inputSizeFrac'  //------------------ обновление ключа для объекта типов информационного окна
      let code =
        `<p>Пожалуйста, вводите целые числа</p>` //- текст информационного окна
      showWarning(code); //------------------------- запуск функции показа информационного окна
    }
  }
  if (inptCnW.value % 1 !== 0) { //-------------- если в поле ввода ширины введено число не делящееся на 1 без остатка, то
    inptCnW.value = Math.floor(inptCnW.value) //- значение поля ввода ширины принимает число округленное назад
  }
  if (inptCnH.value % 1 !== 0) { //-------------- если в поле ввода высоты введено число не делящееся на 1 без остатка, то
    inptCnH.value = Math.floor(inptCnH.value) //- значение поля ввода высоты принимает число округленное назад
  }
  if (inptCnW.value * inptCnH.value > 100000) { //- если произведение чисел введенных в поля ввода ширины и высоты более 100 000, то
    bigWorldShowWarning(); //---------------------- запуск функции показа предупреждения о большом мире
  }
  width = canvas.width = inptCnW.value * cellSize; //--- ширина равна значению введенному в поле ввода
  height = canvas.height = inptCnH.value * cellSize; //- высота равна значению введенному в поле ввода
  cW = inptCnW.value; //-------------------------------- обновление вспомогательной переменной количества ячеек ширины
  cH = inptCnH.value; //-------------------------------- обновление вспомогательной переменной количества ячеек высоты
  drawBackground(); //---------------------------------- запуск функции стартовой отрисовки канвас
  drawCells(); //--------------------------------------- запуск функции отрисовки клеток
}

function bigWorldShowWarning() { //--------- функция показа предупреждения о большом мире
  if (dataWarning.bigWorld === 'noOk') { //- если генерация большого мира содержит 'noOk', то
    dWkey = 'bigWorld'  //------------------ обновление ключа для объекта типов информационного окна
    let code =
      `<p>Внимание, большие карты могут замедлить работу браузера!</p>` //- текст информационного окна
    showWarning(code); //-------------------------------------------------- запуск функции показа информационного окна
  }
}

//Вписать мир в окно
const wrapperCanvas = document.querySelector('#wrapperCanvas'); //- обертка основного канвас
const btnInWindow = document.querySelector('#btnInWindow'); //----- кнопка для вписывания мира в окно просмотра

btnInWindow.addEventListener('click', inWindow); //- при нажатии: вписывание мира в окно просмотра

function inWindow() { //- функция вписывания мира в окно просмотра
  //первичные назначения в 1px для того чтобы убрать из вычисления размеров возможные полосы прокрутки обертки основного канвас
  canvas.width = 1; //-- первичное назначение ширины канвас
  canvas.height = 1; //- первичное назначение высоты канвас
  //размер обертки канвас умноженный на 0.99 и деленный на размер клетки округлен назад
  inptCnW.value = Math.floor(wrapperCanvas.clientWidth * 0.99 / cellSize); //-- значение поля ввода ширины поля
  inptCnH.value = Math.floor(wrapperCanvas.clientHeight * 0.99 / cellSize); //- значение поля ввода высоты поля
  width = canvas.width = inptCnW.value * cellSize; //-------------------------- значение поля ввода ширины поля умноженное на размер клетки
  height = canvas.height = inptCnH.value * cellSize; //------------------------ значение поля ввода высоты поля умноженное на размер клетки
  cW = inptCnW.value; //------------------------------------------------------- обновление переменной количества ячеек ширины
  cH = inptCnH.value; //------------------------------------------------------- обновление переменной количества ячеек высоты
  if (cW > 500) { //----------------------------------------------------------- если количество ячеек ширины больше 500, то
    cW = 500; //--------------------------------------------------------------- количество ячеек ширины присваивает 500
    inptCnW.value = 500; //---------------------------------------------------- обновление поля ввода ширины
    width = canvas.width = 500 * cellSize; //---------------------------------- обновление ширины
  }
  if (cH > 500) { //- если количество ячеек высоты больше 500, то (аналогично для высоты)
    cH = 500;
    inptCnH.value = 500;
    height = canvas.height = 500 * cellSize;
  }
  if (cW * cH > 100000) { //-- если произведение количества ячеек шириы и высоты более 100 000, то
    bigWorldShowWarning(); //- запуск функции показа предупреждения о большом мире
  }
  drawBackground(); //- запуск функции стартовой отрисовки канвас
  drawCells(); //------ запуск функции отрисовки клеток
}

//Цветовое оформление
const inptsColor = document.querySelectorAll('.inpt_color'); //- поля ввода цвета цветового оформления

inptsColor.forEach(e => { //------------- для каждого поля ввода цветового оформления
  e.addEventListener('change', drawCells); //- при изменении: отрисовка клеток
});

//Начальные настройки /сброс настроек
const btnResetSet = document.querySelector('#btnResetSet') //- кнопка сброса настроек

window.addEventListener('load', startSetting); //------- при загрузке окна: запуск функции для начальной отрисовки поля и настроек
btnResetSet.addEventListener('click', startSetting); //- при нажатии кнопки: запуск функции для начальной отрисовки поля и настроек 

function startSetting() { //---------------------------- функция для начальной отрисовки поля и настроек
  cellSize = 10; //------------------------------------- размер клеток
  lifeRule.value = 3; //-------------------------------- значение поля ввода константы зарождения клетки
  deathRuleMin.value = 2; //---------------------------- значение поля ввода минимальной константы сохранения жизни клетки
  deathRuleMax.value = 3; //---------------------------- значение поля ввода максимальной константы сохранения жизни клетки
  colonyColor.value = '#800080'; //--------------------- цвет живых клеток фиолетовый
  emptyColor.value = '#FFFFFF'; //---------------------- цвет пустых клеток белый
  trackColor.value = '#61D6A0'; //---------------------- цвет фона для следа голубой
  btnScaleLarger.disabled = false; //------------------- включение кнопки увеличения масштаба
  btnScaleSmaller.disabled = false; //------------------ включение кнопки уменьшения масштаба
  slctGenSpeed.value = 100; //-------------------------- значение селектора смены поколений
  worldEnd = false; //---------------------------------- мир замкнут на себя
  btnLimitedWorld.textContent = 'Ограничить мир'; //---- текст кнопки режима безграничного мира
  trackMode = false; //--------------------------------- режим следов деактивирован
  canvas.classList.remove('border'); //----------------- удаление класса 'border' для канвас
  btnTrackMode.textContent = 'Включить режим следов' //- текст кнопки режима следов
  inWindow(); //---------------------------------------- запуск функции вписывания мира в окно просмотра
  speedGenСhange(); //---------------------------------- запуск функции изменения скорости смены поколений
  drawBackground();  //--------------------------------- запуск функции стартовой отрисовки канвас
  drawCells(); //--------------------------------------- запуск функции отрисовки клеток
}

//Об управлении с клавиатуры
const btnInformKeys = document.querySelector('#btnInformKeys'); //- кнопка показа информации об управлении с клавиатуры

btnInformKeys.addEventListener('click', () => { //- при нажатии: запуск функции показа информационного окна
  let code = //------------------------------------ код информационного окна
    `<ul class="inform-keys">
        <h2 class="sub-title">Управление:</h2>
        <li><span class="key">A</span> - старт / стоп</li>
        <li><span class="key">S</span> - 1 шаг (при зажатии клавиши функция повторяется)</li>
        <li><span class="key">Del</span> - очистить мир</li>
        <h2 class="sub-title">В режиме отрисовки колонии на карту:</h2>
        <li><span class="key">Q</span> - отразить по горизонтали</li>
        <li><span class="key">W</span> - отразить по вертикали</li>
        <li><span class="key">E</span> - повернуть на 90° влево</li>
        <li><span class="key">R</span> - повернуть на 90° вправо</li>
        <li><span class="key">T</span> - повернуть на 180°</li>
        <h2 class="sub-title">Настройки мира:</h2>
        <li><span class="key">D</span> - вкл/вкл режим границ мира</li>
        <li><span class="key">F</span> - вкл/вкл режим следов</li>
        <li><span class="key">G</span> - вписать размер мира в окно просмотра</li>
        <li><span class="key">+</span> - увеличить масштаб</li>
        <li><span class="key">-</span> - уменьшить масштаб</li>
      </ul>`
  dWkey = 'information'; //- обновление ключа для объекта типов информационного окна
  showWarning(code); //----- запуск функции показа информационного окна
});

//****************************************************************************************************************************************
//КАНВАС ПРЕДПРОСМОТРА

const canvasPreview = document.querySelector('#canvasPreview'); //- канвас предпросмотра колонии
const ctxPC = canvasPreview.getContext('2d'); //------------------- 2D контекст канвас предпросмотра

let widthPC = canvasPreview.width = 100; //---- ширина канвас предпросмотра
let heighthPC = canvasPreview.height = 100; //- высота канвас предпросмотра

let cellsPC = []; //------- массив координат канвас предпросмотра
let cWPC; //--------------- переменная количества координат ширины колонии
let cHPC; //--------------- переменная количества координат высоты колонии
let maxC; //--------------- переменная максимальной координаты колонии
let cellSizePC; //--------- размер ячеек канвас предпросмотра
let strCrdnts = ''; //----- переменная для строки координат готовых колоний
let arrCrdnts = []; //----- переменная для массива координат готовых колоний
let shadowMode = false; //- переменная режима тени (true - активирован, false - деактивирован)

function strToArr() { //------------------------------- функция преобразования строки координат в массив координат
  arrCrdnts = []; //----------------------------------- очистка массива координат
  const xOrY = strCrdnts.slice(0, 1); //--------------- константа первого символа строки (x или y)
  strCrdnts = strCrdnts.slice(1, strCrdnts.length); //- строка координат присваивает строку координат без 1го символа
  strCrdnts = strCrdnts //----------------------------- декодинг символов на числа
    .replaceAll('α', '50').replaceAll('β', '51').replaceAll('γ', '52').replaceAll('δ', '53').replaceAll('ε', '54').replaceAll('ζ', '55')
    .replaceAll('η', '56').replaceAll('θ', '57').replaceAll('ι', '58').replaceAll('κ', '59').replaceAll('λ', '60').replaceAll('μ', '61')
    .replaceAll('ν', '62').replaceAll('ξ', '63').replaceAll('ο', '64').replaceAll('π', '65').replaceAll('ρ', '66').replaceAll('σ', '67')
    .replaceAll('τ', '68').replaceAll('υ', '69').replaceAll('φ', '70').replaceAll('χ', '71').replaceAll('ψ', '72').replaceAll('ω', '73')
    .replaceAll('w', '74').replaceAll('Α', '75').replaceAll('Β', '76').replaceAll('Γ', '77').replaceAll('Δ', '78').replaceAll('Ε', '79')
    .replaceAll('Ζ', '80').replaceAll('Η', '81').replaceAll('Θ', '82').replaceAll('Ι', '83').replaceAll('Κ', '84').replaceAll('Λ', '85')
    .replaceAll('Μ', '86').replaceAll('Ν', '87').replaceAll('Ξ', '88').replaceAll('Ο', '89').replaceAll('Π', '90').replaceAll('Ρ', '91')
    .replaceAll('Σ', '92').replaceAll('Τ', '93').replaceAll('Υ', '94').replaceAll('Φ', '95').replaceAll('Χ', '96').replaceAll('Ψ', '97')
    .replaceAll('Ω', '98').replaceAll('W', '99').replaceAll('a', '10').replaceAll('b', '11').replaceAll('c', '12').replaceAll('d', '13')
    .replaceAll('e', '14').replaceAll('f', '15').replaceAll('g', '16').replaceAll('h', '17').replaceAll('i', '18').replaceAll('j', '19')
    .replaceAll('k', '20').replaceAll('l', '21').replaceAll('m', '22').replaceAll('n', '23').replaceAll('o', '24').replaceAll('p', '25')
    .replaceAll('r', '26').replaceAll('s', '27').replaceAll('t', '28').replaceAll('u', '29').replaceAll('A', '30').replaceAll('B', '31')
    .replaceAll('C', '32').replaceAll('D', '33').replaceAll('E', '34').replaceAll('F', '35').replaceAll('G', '36').replaceAll('H', '37')
    .replaceAll('I', '38').replaceAll('J', '39').replaceAll('K', '40').replaceAll('L', '41').replaceAll('M', '42').replaceAll('N', '43')
    .replaceAll('O', '44').replaceAll('P', '45').replaceAll('R', '46').replaceAll('S', '47').replaceAll('T', '48').replaceAll('U', '49');
  if (xOrY === 'x') { //------------------------------- если 1й символ === x, то
    arrCrdnts = transformCrdnts(); //------------------ массив координат присваивает трансформированную в массив строку координат
  } else { //------------------------------------------ иначе (если 1й символ === y, то)
    const arr = transformCrdnts(); //------------------ массив-посредник присваивает трансформированную в массив строку координат
    for (const item of arr) { //----------------------- цикл перебора координат массива-посредника
      //координаты меняются местами
      arrCrdnts.push([item[1], item[0]]); //- внесение координат в массив координат
    }
  }
  shadowMode = true; //--------------- активация режима тени
  btnResetColony.disabled = false; //- включение кнопки сброса отрисовки колонии на канвас
}

function transformCrdnts() { //------ функция собственно трансформации коротких координат в массив координат
  let str = strCrdnts.split(' '); //- расщепление строки координат по ' ' (пробелам)
  let aArr = []; //------------------ массив для первых координат
  let bArr = []; //------------------ массив для вторых координат

  for (let item of str) { //---------- цикл перебора координат
    item = item.split(':'); //-------- расщепление координат по ':' (двоеточиям)
    aArr.push(Number(item[0])); //---- внесение первых координат в массив с превращением в числа
    bArr.push(item[1].split(',')); //- расщепление вторых координат по ',' (запятым) и внесение в массив
  }
  for (let bC of bArr) { //--------------------------------------------- цикл перебора вторых координат
    for (let j = 0; j < bC.length; j++) //------------------------------ цикл перебора подмассивов вторых координат
      if (bC[j].includes('-')) { //------------------------------------- если подмассив содержит '-' (тире), то
        bC[j] = bC[j].split('-'); //------------------------------------ расщепление подмассива на подподмассив
        for (let k = Number(bC[j][0]); k <= Number(bC[j][1]); k++) { //- цикл перебора числовых значений подподмасиива
          bC[j].push(k); //--------------------------------------------- внесение диапазона в подподмассив
        }
        bC[j].splice(0, 2); //--- удаление первых 2х значений (которые являлись рамками диапазона)
      } else { //---------------- иначе (если подмассив не содержит '-' (тире),то)
        bC[j] = Number(bC[j]) //- превращение подмассива в число
      }
  }
  let newBArr = []; //------------------------------------- массив для измененных координат
  for (let i = 0; i < aArr.length; i++) { //--------------- цикл перебора первых координат
    for (let j = 0; j < bArr[i].length; j++) { //---------- цикл перебора подмассивоа вторых координат
      newBArr.push([aArr[i], bArr[i][j]]); //-------------- внесение первых и вторых координат в массив
      for (let k = 0; k < bArr[i][j].length; k++) { //----- цикл перебора подподмассивов
        newBArr.push([aArr[i], bArr[i][j][k]]); //--------- внесение первых и вторых координат в массив
      }
    }
  }
  let arr = []; //- массив-посредник для чистых координат
  //очистка массива от координат с подмассивами
  for (const item of newBArr) { //- цикл перебора массива для измененных координат
    if (!isNaN(item[1])) { //------ если вторая координата число, то
      arr.push(item); //----------- внесение координат в массив-посредник
    }
  }
  return arr; //- возврат массива-посредника
}

function drawPC() { //----------------- функция отрисовки канвас предпросмотра
  if (shadowMode) { //----------------- если режим тени активирован
    let сrdnsX = []; //---------------- массив X-координат 
    let сrdnsY = []; //---------------- массив Y-координат
    for (const item of arrCrdnts) { //- цикл перебора массива координат колонии
      сrdnsX.push(item[0]); //--------- внесение X-координат в массив
      сrdnsY.push(item[1]); //--------- внесение Y-координат в массив
    }
    cWPC = Math.max(...сrdnsX) + 1; //- присваивание маскимальной координаты из X-координат + 1 (так как координаты начинаются с 0)
    cHPC = Math.max(...сrdnsY) + 1; //- присваивание маскимальной координаты из Y-координат + 1 (так как координаты начинаются с 0)

    if (cWPC > cHPC) { //- если максимальная X-координата больше максимальной Y-координаты, то
      maxC = cWPC //------ количеству координат присваевается максимальная X-координата
    } else { //----------- иначе (если максимальная Y-координата больше максимальной X-координаты, то)
      maxC = cHPC //------ количеству координат присваевается максимальная Y-координата
    }
    cellSizePC = 100 / maxC; //------------------ размер ячейки канвас предпросмотра присваивает 100 / максимальную координату
    canvasPreview.width = cellSizePC * cWPC; //-- ширина канвас предпросмотра присваивает размер ячейки * максимальную X-координтау
    canvasPreview.height = cellSizePC * cHPC; //- высота канвас предпросмотра присваивает размер ячейки * максимальную Y-координтау
    for (let i = 0; i < maxC; i++) { //---------- цикл генерации координат канвас предпросмотра
      cellsPC[i] = [];
      for (let j = 0; j < maxC; j++) {
        cellsPC[i][j] = 0;
      }
    }
    for (const item of arrCrdnts) { //- цикл внесения координат из массива координат колонии
      cellsPC[item[0]][item[1]] = 1;
    }
    for (let i = 0; i < maxC; i++) { //- цикл перебора координат колонии
      for (let j = 0; j < maxC; j++) {
        if (cellsPC[i][j] === 1) { //-------------------------------------------------------------------- если координата содержит 1, то
          ctxPC.fillStyle = 'black'; //------------------------------------------------------------------ отрисовка черной ячейки
          ctxPC.fillRect(i * widthPC / maxC, j * heighthPC / maxC, widthPC / maxC, heighthPC / maxC); //- положение ячейки
        } else { //-------------------------------------------------------------------------------------- иначе (если координата содержит 0, то)
          ctxPC.fillStyle = 'white'; //------------------------------------------------------------------ отрисовка белой ячейки
          ctxPC.fillRect(i * widthPC / maxC, j * heighthPC / maxC, widthPC / maxC, heighthPC / maxC); //- положение ячейки
        }
      }
    }
  }
}

function clearPC() { //--------------------------------------------------- функция очистки канвас предпросмотра
  ctxPC.fillStyle = 'white'; //------------------------------------------- отрисовка канвас предпросмотра белым
  ctxPC.fillRect(0, 0, widthPC, heighthPC); //---------------------------- весь канвас предпросмотра
  shadowMode = false; //-------------------------------------------------- деактивация режима тени
  strCrdnts = ''; //------------------------------------------------------ очистка переменной строки координат колонии
  arrCrdnts = []; //------------------------------------------------------ очистка массива координат колонии
  nameColony.textContent = 'Название колонии'; //------------------------- обновление текста названия выбранной колонии
  if (localStorage.length !== 0) { //------------------------------------- если локальное хранилище не пусто (длина не равна 0), то
    optFirstSlctCustomColony.textContent = 'Выбрать' //------------------- обновление текста первого option селекта пользовательских колоний
  } else { //------------------------------------------------------------- иначе (если локальное хранилище пусто (длина равна 0), то)
    optFirstSlctCustomColony.textContent = 'Здесь будут ваши колонии'; //- обновление текста первого option селекта пользовательских колоний
    slctCustomColony.disabled = true; //---------------------------------- выключение селекта пользовательских колоний
  }
  btnDelColony.disabled = true; //--- выключение кнопки удаления пользовательской колонии
  btnResetColony.disabled = true; //- выключение кнопки сброса отрисовки колонии на канвас
}

//****************************************************************************************************************************************
//БЛОК ВЫВОДА КОЛОНИЙ НА КАНВАС 

//Отрисовка тени колонии
//блок для уменьшения нагрузки на браузер (перерисовка канвас будет происходить при изменении координат курсора мыши)

let x = 0; //- переменная положения курсора мыши по X-координате
let y = 0; //- переменная положения курсора мыши по Y-координате

let coursorXList = null; //- переменная списка для X-координат
let coursorYList = null; //- переменная списка для Y-координат

canvas.addEventListener('mousemove', e => { //- при движении курсора мыши: вычисление координат
  //взят модуль настоящей координаты курсора мыши, поделен на размер клетки и округлен в меньшую сторону
  x = Math.floor(Math.abs(e.offsetX) / cellSize); //- переменная с X-координатой курсора мыши
  y = Math.floor(Math.abs(e.offsetY) / cellSize); //- переменная с Y-координатой курсора мыши
  changeCrdnts(); //--------------------------------- запуск функции выявления изменения координат
});

canvas.addEventListener('touchmove', e => { //-- при движении касания сенсорного экрана: вычисление координат
  let rect = canvas.getBoundingClientRect(); //- перменная положения канвас относительно окна просмотра
  //из положения касания вычтено положение канвас относительно окна просмотра, поделено на размер клетки и округлено назад
  x = Math.floor((e.touches[0].clientX - rect.x) / cellSize); //- переменная с X-координатой касания сенсорного экрана
  y = Math.floor((e.touches[0].clientY - rect.y) / cellSize); //- переменная с Y-координатой касания сенсорного экрана
  changeCrdnts(); //--------------------------------------------- запуск функции выявления изменения координат
});

const mouseXcoordinate = document.querySelector('#mouseXcoordinate'); //- текст для X-координаты
const mouseYcoordinate = document.querySelector('#mouseYcoordinate'); //- текст для Y-координаты

function changeCrdnts() { //------------------------- функция выявления изменения координат
  coursorXList = { value: x, next: coursorXList }; //- добавление значения в начало списка для X-координат
  coursorYList = { value: y, next: coursorYList }; //- добавление значения в начало списка для Y-координат
  if (coursorXList.next?.next) { //------------------- если существует 3й "элемент" списка для X-координат
    coursorXList.next.next = null; //----------------- удаление 3го элемента
  }
  if (coursorYList.next?.next) { //--- если существует 3й "элемент" списка для Y-координат
    coursorYList.next.next = null; //- удаление 3го элемента
  }

  if (coursorXList.value !== coursorXList.next?.value || //- если 1й элемент не равен 2му элементу списка для X-координат, ИЛИ
    coursorYList.value !== coursorYList.next?.value) { //--- если 1й элемент не равен 2му элементу списка для Y-координат
    if (shadowMode) drawShadow(); // ----------------------- если режим тени активирован, то запуск функции отрисовки тени колонии
    mouseXcoordinate.textContent = `X: ${x + 1}`; //-------- текст для X-координаты
    mouseYcoordinate.textContent = `Y: ${y + 1}`; //-------- текст для Y-координаты
  }
}

let worldNewSize; //- переменная нового размера мира

function drawShadow() { //----------- функция отрисовки тени колонии
  if (cWPC <= cW && cHPC <= cH) { //- если ширина и высота колонии меньше или равна ширине и высоте карты, то
    drawCells(); //------------------ запуск функции отрисовки клеток (для очистки пройденного указателем мыши пути)
    //блок запрета отрисовки тени за границами мира
    let a = 0; //------------- переменная блока границы по ширине
    let b = 0; //------------- переменная блока границы по высоте
    if (x > cW - cWPC) { //--- если X-координата больше чем ширина - ширина колонии, то
      a = cWPC - (cW - x); //- пременная присваивает ширину колонии за вычетом разницы ширины мира и X-координаты
    }
    if (y > cH - cHPC) { //- аналогично для Y-координаты
      b = cHPC - (cH - y);
    }
    for (const item of arrCrdnts) { //- цикл перебора координат колонии
      if (step) { //------------------- если предыдущее поколение, то
        //координата в положении колонии + координата мыши - переменная блока границы
        if (cells1[item[0] + x - a][item[1] + y - b] === 0) { //- если координаты предыдущего поколения содержат 0, то
          shadow(item[0] + x - a, item[1] + y - b); //----------- отрисовка тени
        }
      } else { //------------------------------------------------ иначе (если последующее поколение, то) (аналогично для последующего поколения)
        if (cells2[item[0] + x - a][item[1] + y - b] === 0) {
          shadow(item[0] + x - a, item[1] + y - b);
        }
      }
    }
  } else { //--------------------- иначе (если ширина или высота колонии больше ширины или высоты карты)
    if (maxC > 498) { //---------- если максимальная координата колонии больше 498, то 
      worldNewSize = 500; //------ новый размер мира присваивает 500
    } else { //------------------- иначе (если максимальная координата колонии меньше или равна 498, то)
      worldNewSize = maxC + 2; //- новый размер мира присваивает максимальное координату колонии + 2
    }
    dWkey = 'bigColony'; //- обновление ключа для объекта типов информационного окна
    let code = //----------- текст информационного окна
      `<p>Карта меньше выбранной вами колонии.<br />
      Увеличить карту под подходящий размер для колонии?</p>`
    showWarning(code); //- запуск функции показа информационного окна
  }
}

//Отрисовка колонии и ручного рисунка
const nameColony = document.querySelector('#nameColony') //- название выбранной колонии

canvas.addEventListener('touchend', () => { //- при окончании касания сенсорного экрана
  if (shadowMode) { //------------------------- если режим тени активирован, то
    drawColony(); //--------------------------- запуск функции отрисовки колонии
  }
});

canvas.addEventListener('click', e => { //- при нажатии на канвас
  if (shadowMode) { //--------------------- если режим тени активирован, то
    drawColony(); //----------------------- запуск функции отрисовки колонии
  } else { //------------------------------ иначе (если режим тени деактивирован, то)
    handDraw(e); //------------------------ запуск функции ручной отрисовки
  }
});

function drawColony() { //- функция отрисовки колонии
  //блок запрета отрисовки колонии за границами мира
  let a = 0; //------------- переменная блока границы по ширине
  let b = 0; //------------- переменная блока границы по высоте
  if (x > cW - cWPC) { //--- если X-координата больше чем ширина - ширина колонии, то
    a = cWPC - (cW - x); //- пременная присваивает ширину колонии за вычетом разницы ширины мира и X-координаты
  }
  if (y > cH - cHPC) { //- аналогично для Y-координаты
    b = cHPC - (cH - y);
  }
  //отрисовка колонии
  for (const item of arrCrdnts) { //------------------- цикл генерации координат готовых колоний
    if (step) { //------------------------------------- если предыдущее поколение
      cells1[item[0] + x - a][item[1] + y - b] = 1; //- присвоение координатам предыдущего поколения 1(оживление) в положении тени
      life(item[0] + x - a, item[1] + y - b); //------- запуск отрисовки живых клеток
    } else { //---------------------------------------- иначе (если последующее поколение, то) (аналогично для последующего поколения)
      cells2[item[0] + x - a][item[1] + y - b] = 1;
      life(item[0] + x - a, item[1] + y - b);
    }
  }
  clearPC(); //- запуск функции очистки канвас предпросмотра
}

function handDraw(e) { //---------- функция ручной отрисовки
  x = e.offsetX; //---------------- переменная с координатой нажатия по X
  y = e.offsetY; //---------------- переменная с координатой нажатия по Y
  x = Math.floor(x / cellSize); //- деление координаты на cellSize и округление в меньшую сторону
  y = Math.floor(y / cellSize); //- деление координаты на cellSize и округление в меньшую сторону
  if (step) { //------------------- предыдущее поколение, то
    if (cells1[x][y] === 0) { //--- если координаты предыдущего поколения содержат 0, то
      cells1[x][y] = 1; //--------- присваиваится координатам 1
      life(x, y); //--------------- запуск отрисовки живых клеток
    } else { //-------------------- иначе (если координаты содержат 1, то)
      cells1[x][y] = 0; //--------- присваиваится координатам 0
      if (trackMode) { //-------- если режим следов активирован, то
        track(x, y); //---------- запуск отрисовки темного фона
      } else { //---------------- иначе (если режим следов деактивирован), то
        empty(x, y); //---------- запуск отрисовки пустых клеток
      }
    }
  } else { //---------------------- иначе (если последующее поколение, то) (аналогично для последующего поколения)
    if (cells2[x][y] === 0) {
      cells2[x][y] = 1;
      life(x, y);
    } else {
      cells2[x][y] = 0;
      if (trackMode) {
        track(x, y);
      } else {
        empty(x, y);
      }
    }
  }
}

//Сброс колонии
const btnResetColony = document.querySelector('#btnResetColony'); //- кнопка сброса отрисовки колонии на канвас
btnResetColony.disabled = true; //- выключение кнопки сброса отрисовки колонии на канвас

btnResetColony.addEventListener('click', resetColony); //- при нажатии: запуск функции сброса отрисовки колонии на канвас

function resetColony() { //- функция сброса отрисовки колонии на канвас
  clearPC(); //------------- запуск функции очистки канвас предпросмотра
  drawCells(); //----------- запуск функции отрисовки клеток
}

//****************************************************************************************************************************************
//БЛОК ТРАНСФОРМАЦИИ КОЛОНИЙ

const btnHorizReflection = document.querySelector('#btnHorizReflection'); //- кнопка отражения колонии по горизонтали
const btnVertReflection = document.querySelector('#btnVertReflection'); //--- кнопка отражения колонии по вертикали
const btnRightTurn = document.querySelector('#btnRightTurn'); //------------- кнопкаа поворота колонии вправо на 90 градусов
const btnLeftTurn = document.querySelector('#btnLeftTurn'); //--------------- кнопка поворота колонии влево на 90 градусов
const btnRotate180deg = document.querySelector('#btnRotate180deg'); //------ кнопка поворота колонии на 180 градусов

btnHorizReflection.addEventListener('click', horizReflection); //- при нажатии на кнопку запуск функции отражения колонии по горизонтали
btnHorizReflection.addEventListener('click', drawPC); //---------- при нажатии на кнопку запуск функции отрисовки канвас предпросмотра
btnVertReflection.addEventListener('click', vertReflection); //--- при нажатии на кнопку запуск функции отражения колонии по вертикали
btnVertReflection.addEventListener('click', drawPC); //----------- при нажатии на кнопку запуск функции отрисовки канвас предпросмотра
btnRightTurn.addEventListener('click', rightTurn); //------------- при нажатии на кнопку запуск функции поворота колонии вправо на 90 градусов
btnRightTurn.addEventListener('click', drawPC); //---------------- при нажатии на кнопку запуск функции отрисовки канвас предпросмотра
btnLeftTurn.addEventListener('click', leftTurn); //--------------- при нажатии на кнопку запуск функции поворота колонии влево на 90 градусов
btnLeftTurn.addEventListener('click', drawPC); //----------------- при нажатии на кнопку запуск функции отрисовки канвас предпросмотра
btnRotate180deg.addEventListener('click', rotate180deg); //------- при нажатии на кнопку запуск функции поворота колонии на 180 градусов
btnRotate180deg.addEventListener('click', drawPC); //------------- при нажатии на кнопку запуск функции отрисовки канвас предпросмотра

function horizReflection() { //-------- функция отражения координат колонии по горизонтали (слева направо)
  if (shadowMode) { //----------------- если режим тени активирован, то
    const crdntX = []; //-------------- массив для X-координат
    const newArr = []; //-------------- массив новых координат колонии
    for (const item of arrCrdnts) { //- цикл перебора массива координат колонии
      crdntX.push(item[0]); //--------- внесение в массив X-координат
    }
    for (const item of arrCrdnts) { //- цикл изменения координат
      //0 - X-координата + максимальная X-координата, Y-координата неизменна
      newArr.push([0 - item[0] + Math.max(...сrdnsX), item[1]]); //- изменение координат и внесение в новый массив
    }
    strCrdnts = newArr.join(' '); //- склеивание массива в строку и обновление строки координат
    arrCrdnts = newArr; //----------- обновление массива координат
    drawShadow(); //----------------- запуск функции отрисовки тени колонии
  }
}
function vertReflection() { //--------- функция отражения координат колонии по вертикали (сверху вниз)
  if (shadowMode) { //----------------- если режим тени активирован, то
    const crdntY = []; //-------------- массив для Y-координат
    const newArr = []; //-------------- массив новых координат колонии
    for (const item of arrCrdnts) { //- цикл перебора массива координат колонии
      crdntY.push(item[1]); //--------- внесение в массив Y-координат
    }
    for (const item of arrCrdnts) { //- цикл изменения координат
      // X-координата неизменна, 0 - Y-координата + максимальная Y-координата
      newArr.push([item[0], 0 - item[1] + Math.max(...сrdnsY)]); //- изменение координат и внесение в новый массив
    }
    strCrdnts = newArr.join(' '); //- склеивание массива в строку
    arrCrdnts = newArr; //----------- обновление массива координат
    drawShadow(); //----------------- запуск функции отрисовки тени колонии
  }
}
function rightTurn() { //-------------- функция поворота на 90 градусов по часовой (поворот вправо)
  if (shadowMode) { //----------------- если режим тени активирован, то
    const newArr = []; //-------------- массив новых координат колонии
    for (const item of arrCrdnts) { //- цикл изменения координат
      // координаты меняются местами
      newArr.push([item[1], item[0]]); //- изменение координат и внесение в новый массив
    }
    arrCrdnts = newArr; //- обновление массива координат колонии
    horizReflection(); //-- запуск функции отражения координат колонии по горизонтали (слева направо)
    drawShadow(); //------- запуск функции отрисовки тени колонии
  }
}
function leftTurn() { //--------------- функция поворота на 90 градусов против часовой (поворот влево)
  if (shadowMode) { //----------------- если режим тени активирован, то
    const newArr = []; //-------------- массив новых координат колонии
    for (const item of arrCrdnts) { //- цикл изменения координат
      // координаты меняются местами
      newArr.push([item[1], item[0]]); //- изменение координат и внесение в новый массив
    }
    arrCrdnts = newArr; //- обновление массива координат колонии
    vertReflection(); //--- запуск функции отражения координат колонии по вертикали (сверху вниз)
    drawShadow(); //------- запуск функции отрисовки тени колонии
  }
}
function rotate180deg() { //- функция поворота на 180 градусов
  if (shadowMode) { //------- если режим тени активирован, то
    horizReflection(); //---- запуск функции отражения координат колонии по горизонтали (слева направо)
    vertReflection(); //----- запуск функции отражения координат колонии по вертикали (сверху вниз)
    drawShadow(); //--------- запуск функции отрисовки тени колонии
  }
}

//****************************************************************************************************************************************
// БЛОК ВЫБОРА ГОТОВЫХ КОЛОНИЙ ПРИ ИЗМЕНЕНИИ СООТВЕТСТВУЮЩИХ СЕЛЕКТОРОВ

const defaultColony = document.querySelector('#defaultColony'); //- секция координат готовых колоний

window.addEventListener('load', populate()); //- при загрузке окна: запуск функции загрузки данных готовых колоний

async function populate() { //------------------------- асинхронная функция загрузки данных готовых колоний
  try { //--------------------------------------------- попытка:
    const request = new Request('coloniesDB.json'); //- объявление объекта запроса
    const response = await fetch(request); //---------- запрос и ответ от адреса
    const colonies = await response.json(); //--------- запрос и ответ от json
    addDefaultColonyToSelect(colonies); //------------- запуск функции построения панелей с селектами колоний
    dropDownFunc(); //--------------------------------- запуск функции функционирования открытия закрытия выпадающих панаелей
    colonySelection(colonies); //---------------------- запуск функции выбора готовых колоний
  } catch { //----------------------------------------- при ошибке:
    defaultColony.textContent = //--------------------- текст секции координат готовых колоний
      `К сожалению данные колоний не загрузились.`
  }
}

function addDefaultColonyToSelect(obj) { //- функция построения панелей с селектами колоний
  for (const group of obj.groups) { //------ цикл перебора групп колоний
    defaultColony.innerHTML += //----------- html-код секции координат готовых колоний
      `<button class="btn btn_tab btn_tab_drop-down btn_tab_drop-down_default-colony close">
        ${group.name}
      </button>`
    let panel = document.createElement('div'); //------------------------------------------------ генерация элемента div
    panel.setAttribute('class', 'panel panel_drop-down panel_drop-down_default-colony none'); //- добавление атрибута class для элемента div
    defaultColony.appendChild(panel); //--------------------------------------------------------- добавление панели в секцию координат готовых колоний
    for (const subgroup of group.subgroups) { //------------------------------------------------- цикл перебора подгрупп колоний
      let select = document.createElement('select'); //------------------------------------------ генерация элемента select
      select.setAttribute('class', 'slct'); //--------------------------------------------------- добавление атрибута class со значением 'slct'
      select.innerHTML = `<option value="0" selected disabled>${subgroup.name}</option>`; //----- html-код элемента select
      panel.appendChild(select); //-------------------------------------------------------------- добавление эдемента select в панель
      for (const colony of subgroup.colonies) { //----------------------------------------------- цикл перебора колоний
        select.insertAdjacentHTML('beforeend', `<option>${colony.name}</option>`); //------------ добавление html-кода перед закрывающим тегом элемента select
      }
    }
  }
}

function colonySelection(obj) { //------------------- функция выбора готовых колоний
  defaultColony.addEventListener('change', e => { //- при изменении значения селектора
    for (const group of obj.groups) { //------------- цикл перебора групп колоний
      for (const subgroup of group.subgroups) { //--- цикл перебора подгрупп колоний
        for (const colony of subgroup.colonies) { //- цикл перебора колоний
          switch (e.target.value) { //--------------- переключатель - значение селектора
            //данные из JSON готовых колоний
            case colony.name: strCrdnts = colony.coordinates; //- случай - название колонии: строка координат примимает координаты колонии
              break;
          }
        }
      }
    }
    strToArr(); //---------------------------------------------------------- запуск функции преобразования строки координат в массив координат
    drawPC(); //------------------------------------------------------------ запуск функции отрисовки канвас предпросмотра
    drawShadow(); //-------------------------------------------------------- запуск функции отрисовки тени колонии
    e.target.blur(); //----------------------------------------------------- добавление нефокусировки к селекту (разрешение проблемы смены колоний из-за нажатия клавиш)
    nameColony.textContent = e.target.value; //----------------------------- обновление текста названия выбранной колонии
    if (localStorage.length !== 0) { //------------------------------------- если локальное хранилище не пусто (длина не равна 0), то
      optFirstSlctCustomColony.textContent = 'Выбрать' //------------------- обновление текста первого option селекта пользовательских колоний
    } else { //------------------------------------------------------------- иначе (если локальное хранилище пусто (длина равна 0), то)
      optFirstSlctCustomColony.textContent = 'Здесь будут ваши колонии'; //- обновление текста первого option селекта пользовательских колоний
    }
    btnDelColony.disabled = true; //- выключение кнопки удаления пользовательской колонии
  });
}

//****************************************************************************************************************************************
//БЛОК ВЫБОРА, СОХРАНЕНИЯ И УДАЛЕНИЯ ПОЛЬЗОВАТЕЛЬСКИХ КОЛОНИЙ

//Сохранение колонии
const btnSaveStr = document.querySelector('#btnSaveStr'); //------------- кнопка сохранения строки координат
const inptCustomName = document.querySelector('#inptCustomName'); //----- поле ввода имени пользовательской колонии
const slctCustomColony = document.querySelector('#slctCustomColony'); //- селект имён пользовательских колоний
const inpCustomCrdnts = document.querySelector('#inpCustomCrdnts'); //--- поле ввода пользовательских координат

btnSaveStr.addEventListener('click', () => { //- при нажатии на кнопку: сохранение пользовательской колонии
  if (inpCustomCrdnts.value === '') { //-------- если поле ввода пользовательских координат пусто, то
    arrToStr(); //------------------------------ запуск функции преобразования массива координат в строку координат
    if (strCrdnts !== '') { //------------------ если строка координат не пустая, то
      saveStr(); //----------------------------- запуск функции сохранения координат пользовательских колоний
    } else { //--------------------------------- иначе (если строка координат пустая), то
      dWkey = 'information'; //----------------- обновление ключа для объекта типов информационного окна
      let code = //----------------------------- текст информационного окна
        `<p>Создайте свою колонию на карте
        или введите свои координаты в поле ввода координат!</p>`
      showWarning(code); //- запуск функции показа информационного окна
    }
  } else { //------------------------------- иначе (если поле ввода пользовательских координат содержит строку, то)
    if (checkCustomCrdnts()) { //----------- если функция проверки введенного текста в поле ввода возвращает true, то
      strCrdnts = inpCustomCrdnts.value; //- строка координат присваивает значение поля ввода для пользовательских координат
      saveStr(); //------------------------- запуск функции сохранения координат пользовательских колоний
    } else { //----------------------------- иначе (если функция проверки правильности введенных координат вернула false, то)
      let code = //------------------------- текст информационного окна
        `<p><strong>Введенные координаты некорректны!</strong><br />
        Вводите координаты сгенерированные в данном приложении.<br />
        Они должы иметь примерный вид: <span class="code">"y0:1,6,b 1:2,7,c 2:0-2,5-7,a-c"</span>,
        где первый символ обозначает первую координату в парах координат, пары координат разделены пробелами,
        первая от второй координаты разделены двоеточием, вторые координаты записаны через запятую для одиночных координат
        или через тире для диапазонов координат, координаты не могут быть меньше 0 и больше 499,
        двузначные числа могут быть заменены буквенными символами</p>`
      dWkey = 'information'; //- обновление ключа для объекта типов информационного окна
      showWarning(code); //----- запуск функции показа информационного окна
    }
  }
});

function checkCustomCrdnts() { //----------------------- функция проверки правильности введенных координат
  let customStr = inpCustomCrdnts.value; //------------- переменная для введенных пользовательских координат
  if (!(inpCustomCrdnts.validity.patternMismatch)) { //- если введенное в поле ввода соответсвтует html-паттерну, то
    customStr = customStr.split(/[\s:,-]+/); //--------- расщепление строки на массив по символам (пробел, двоеточие, запятая, тире)
    for (let i = 0; i < customStr.length; i++) { //----- цикл перебора массива строк
      customStr[i] = Number(customStr[i]); //----------- преобразование строк в числа
    }
    for (const item of customStr) { //- цикл перебора массива
      if (item < 0 || item > 499) { //- если в массиве есть отрицательные числа ИЛИ числа больше 499, то
        return false; //--------------- функция возвращает false
      } else { //---------------------- иначе (если в массиве нет отрицательныx чисел ИЛИ числел больше 499, то)
        return true; //---------------- функция возвращает true
      }
    }
  } else { //-------- иначе (если введенное в поле ввода не соответсвтует html-паттерну, то)
    return false; //- функция возвращает false
  }
}

//показ информационного окна при наведении на иконку вопроса ввода кользовательских координат
const icoInpCustomCrdnts = document.querySelector('#icoInpCustomCrdnts'); //- иконка вопроса ввода кользовательских координат

icoInpCustomCrdnts.addEventListener('click', () => { //- при нажатии: показ информационного окна
  let code = //----------------------------------------- текст информационного окна
    `<p>Если у вас имеются координаты колонии сгенерированные в данном приложении, можете ввести их поле ввода и нажать "Cохранить".
    Если оставите поле ввода пустым, сохранятся координаты колонии находящейся на карте.<br />
    Они должы иметь примерный вид: <span class="code">"y0:1,6,b 1:2,7,c 2:0-2,5-7,a-c"</span>,
    где первый символ обозначает первую координату в парах координат, пары координат разделены пробелами,
    первая от второй координаты разделены двоеточием, вторые координаты записаны через запятую для одиночных координат
    или через тире для диапазонов координат, координаты не могут быть меньше 0 и больше 499,
    двузначные числа могут быть заменены буквенными символами</p>`
  dWkey = 'information'; //- обновление ключа для объекта типов информационного окна
  showWarning(code); //----- запуск функции показа информационного окна
});

//показ информационного окна при наведении на иконку вопроса ввода констант эволюции
const icoInpLifeRules = document.querySelector('#icoInpLifeRules'); //- иконка вопроса ввода констант эволюции

icoInpLifeRules.addEventListener('click', () => { //- при нажатии: показ информационного окна
  let code = //-------------------------------------- текст информационного окна
    `<p><b>B</b> – количество-клеток соседей способных зародить новую клетку,<br />
    <b>S</b> – минимальное и максимальное количество клеток-соседей способных сохранить жизнь клетки.<br />
    <b>B3S23</b> – правило для классической игры "Жизнь", которая наиболее разнообразна и изучена.<br />
    Можете попробовать другие правила, например <b>B3S35</b></p>`
  dWkey = 'information'; //- обновление ключа для объекта типов информационного окна
  showWarning(code); //----- запуск функции показа информационного окна
});


function arrToStr() { //- функция преобразования координат
  //преобразование нативных координат в длинные координаты
  const colony = []; //------------- массив для нативных координат колонии
  const colonyX = []; //------------ массив для нативных X-координат
  const colonyY = []; //------------ массив для нативных Y-координат
  for (let i = 0; i < cW; i++) { //- цикл перебора всех координат (для внедрения координат колонии в массив colony)
    for (let j = 0; j < cH; j++) {
      if (cells1[i][j] === 1 || cells2[i][j] === 1) { //- если клетка предыдущего ИЛИ последующего поколения содержит 1, то
        colony.push([i, j]); //-------------------------- добавление координат в массив colony
      }
    }
  }
  if (colony.length > 0) { //------- если длина массива для нативных координат колонии больше 0, то
    for (const item of colony) { //- цикл внесения координат колонии в массивы X и Y координат
      colonyX.push(item[0]); //----- внесение в массив X-координат
      colonyY.push(item[1]); //----- внесение в массив Y-координат
    }
    for (const item of colony) { //- цикл изменения координат (сброс колонии к началу координат)
      // X-координата - минимальная X-координата, Y-координата - минимальная Y-координата
      arrCrdnts.push([item[0] - Math.min(...colonyX), item[1] - Math.min(...colonyY)]); //- изменение координат и внесение в массив координат
    }
    //преобразование координат в короткие координаты
    let strX = xyStrCrdnts(0, 1); //----- переменная строки коротких координат по X принимает значение функции преобразования
    let strY = xyStrCrdnts(1, 0); //----- переменная строки коротких координат по Y принимает значение функции преобразования

    strX = `x${strX}`; //---------------- добавление символа 'x' к строке коротких координат по X
    strY = `y${strY}`; //---------------- добавление символа 'y' к строке коротких координат по Y
    if (strX.length <= strY.length) { //- если длина строки коротких координат по X меньше или равна длине строки коротких координат по Y, то
      strCrdnts = strX; //--------------- строка координат принимает строку коротких координат по X
    } else { //-------------------------- иначе (если длина строки коротких координат по X больше длины строки коротких координат по Y, то)
      strCrdnts = strY; //--------------- строка координат принимает строку коротких координат по Y
    }
  }

}

function xyStrCrdnts(a, b) { //------ функция преобразования длинных координат в короткие с аргументами порядка первых и вторых координат
  const crdntsA = []; //------------- массив для длинных первых координат
  const crdntsB = []; //------------- массив для длинных вторых координат
  for (const item of arrCrdnts) { //- цикл перебора длинных координат
    crdntsA.push(item[a]); //-------- внесение в массив первых координат
    crdntsB.push(item[b]); //-------- внесение в массив вторых координат
  }
  const aClstr = []; //-------------------------------- массив для неповторяющихся первых координат
  const bClstr = []; //-------------------------------- массив для вторых координат сопряженных с первыми координатами
  for (let i = 0; i <= Math.max(...crdntsA); i++) { //- цикл перебора для будущих неповторяющихся первых координат (по максимальной первой координате)
    for (let j = 0; j < crdntsA.length; j++) { //------ цикл перебора первых координат
      if (crdntsA[j] === i) { //----------------------- если первая координата равна счету, то
        aClstr.push(i); //----------------------------- внесение счета в массив
        break; //-------------------------------------- завершение итерации
      }
    }
    bClstr.push([]); //- генерация пустых подмассивов для вторых координат по количеству неповторяющихся первых координат
  }
  let bFullClstr = []; //------------------------- массив для полных вторых координат
  for (let i = 0; i < bClstr.length; i++) { //---- цикл перебора массива для вторых координат сопряженных с первыми координатами
    for (let j = 0; j < crdntsA.length; j++) { //- цикл перебора первых координат
      if (crdntsA[j] === i) { //------------------ если первая координата равна счету, то
        bClstr[i].push(crdntsB[j]); //------------ внесение вторых координат в массив для вторых координат сопряженных с первыми координатами
      }
    }
    //сокращение вторых координат
    let sliceNum = [0]; //-------------------------- массив для адресов вырезания координат
    for (let j = 0; j < bClstr[i].length; j++) { //- цикл перебора массива для вторых координат сопряженных с первыми координатами
      if (bClstr[i][j + 1] - bClstr[i][j] > 1) { //- если вторая координата меньше последующей более чем на 1, то
        sliceNum.push(j + 1); //-------------------- внесение счета + 1 в массив
      }
    }
    let shortB = []; //---------------------------------------------- массив для вторых координат
    for (let j = 0; j < sliceNum.length; j++) { //------------------- цикл перебора массива для адресов вырезания координат
      shortB.push(bClstr[i].slice(sliceNum[j], sliceNum[j + 1])); //- внесение вторых координат группами в массив
    }
    for (let j = 0; j < shortB.length; j++) { //---------------------------- цикл перебора массива для вторых координат
      if (shortB[j].length > 1) { //---------------------------------------- если длина второй координаты больше 1, то
        shortB[j] = `${shortB[j][0]}-${shortB[j][shortB[j].length - 1]}` //- создание диапазона
      }
    }
    bClstr[i] = shortB; //-------------- вторая координата принимает массив
    bClstr[i] = bClstr[i].join(','); //- соединение вторых координат запятыми
    if (bClstr[i] !== '') { //---------- если вторая координата не пуста, то
      bFullClstr.push(bClstr[i]); //---- внесение второй координаты в массив для полных вторых координат
    }
  }
  let shortStrCrdnst = []; //-------------------------------- массив для коротких координат
  for (let i = 0; i < aClstr.length; i++) { //--------------- цикл перебора массива для неповторяющихся первых координат
    shortStrCrdnst.push(`${aClstr[i]}:${bFullClstr[i]}`); //- внесение неповторяющейся первой координаты и полной второй координаты в массив
  }
  shortStrCrdnst = shortStrCrdnst.join(' '); //- cоединение строки координат по ' ' (пробелам)
  shortStrCrdnst = shortStrCrdnst //------------ кодинг чисел на символы 
    .replaceAll('50', 'α').replaceAll('51', 'β').replaceAll('52', 'γ').replaceAll('53', 'δ').replaceAll('54', 'ε').replaceAll('55', 'ζ')
    .replaceAll('56', 'η').replaceAll('57', 'θ').replaceAll('58', 'ι').replaceAll('59', 'κ').replaceAll('60', 'λ').replaceAll('61', 'μ')
    .replaceAll('62', 'ν').replaceAll('63', 'ξ').replaceAll('64', 'ο').replaceAll('65', 'π').replaceAll('66', 'ρ').replaceAll('67', 'σ')
    .replaceAll('68', 'τ').replaceAll('69', 'υ').replaceAll('70', 'φ').replaceAll('71', 'χ').replaceAll('72', 'ψ').replaceAll('73', 'ω')
    .replaceAll('74', 'w').replaceAll('75', 'Α').replaceAll('76', 'Β').replaceAll('77', 'Γ').replaceAll('78', 'Δ').replaceAll('79', 'Ε')
    .replaceAll('80', 'Ζ').replaceAll('81', 'Η').replaceAll('82', 'Θ').replaceAll('83', 'Ι').replaceAll('84', 'Κ').replaceAll('85', 'Λ')
    .replaceAll('86', 'Μ').replaceAll('87', 'Ν').replaceAll('88', 'Ξ').replaceAll('89', 'Ο').replaceAll('90', 'Π').replaceAll('91', 'Ρ')
    .replaceAll('92', 'Σ').replaceAll('93', 'Τ').replaceAll('94', 'Υ').replaceAll('95', 'Φ').replaceAll('96', 'Χ').replaceAll('97', 'Ψ')
    .replaceAll('98', 'Ω').replaceAll('99', 'W').replaceAll('10', 'a').replaceAll('11', 'b').replaceAll('12', 'c').replaceAll('13', 'd')
    .replaceAll('14', 'e').replaceAll('15', 'f').replaceAll('16', 'g').replaceAll('17', 'h').replaceAll('18', 'i').replaceAll('19', 'j')
    .replaceAll('20', 'k').replaceAll('21', 'l').replaceAll('22', 'm').replaceAll('23', 'n').replaceAll('24', 'o').replaceAll('25', 'p')
    .replaceAll('26', 'r').replaceAll('27', 's').replaceAll('28', 't').replaceAll('29', 'u').replaceAll('30', 'A').replaceAll('31', 'B')
    .replaceAll('32', 'C').replaceAll('33', 'D').replaceAll('34', 'E').replaceAll('35', 'F').replaceAll('36', 'G').replaceAll('37', 'H')
    .replaceAll('38', 'I').replaceAll('39', 'J').replaceAll('40', 'K').replaceAll('41', 'L').replaceAll('42', 'M').replaceAll('43', 'N')
    .replaceAll('44', 'O').replaceAll('45', 'P').replaceAll('46', 'R').replaceAll('47', 'S').replaceAll('48', 'T').replaceAll('49', 'U');
  return shortStrCrdnst; //- возврат короткой закодированной строки координат
}

function saveStr() { //----------------- функция сохранения координат пользовательских колоний
  if (inptCustomName.value !== '') { //- если поле ввода имени пользовательской колонии не пустое, то
    //исправление бага при удалении колонии со значением названия '0'
    if (inptCustomName.value === '0') { //- если введенный текст в поле ввода равен '0', то
      inptCustomName.value = '0.'; //------ поле ввода принимает '0.'
    }
    if (localStorage.getItem(inptCustomName.value) === null) { //- если ключ локального хранилища с именем колонии введенным в поле возвращает null, то
      localStorage.setItem(inptCustomName.value, strCrdnts); //--- сохранить данный ключ и значение строки координат в локальном хранилище
      slctCustomColony.insertAdjacentHTML('beforeend', //--------- добавление html-кода со значением введенным в поле перед закрывающим тегом селекта
        `<option value="${inptCustomName.value}">
        ${inptCustomName.value}
      </option>`);
      inptCustomName.value = ''; //---------------------- очистка поля ввода имени пользовательской колонии
      if (dataWarning.firstCustomColony === "noOk") { //- если в объекте dataWarning ключ firstCustomColony === "noOk", то
        firstCustomColonyShowWarning(); //--------------- запуск функции показа предупреждения о сохранении колоний в хранилище браузера
      }
    } else { //----- иначе (если ключ локального хранилища совпал с именем введенным в поле), то
      let code = //- текст информационного окна
        `<p>У вас уже есть колония под названием "${inptCustomName.value}".<br />
      Хотите переписать данные колонии "${inptCustomName.value}"?</p>`
      dWkey = 'rewriteCustomColony'; //- обновление ключа для объекта типов информационного окна
      showWarning(code); //------------- запуск функции показа информационного окна
    }
    inpCustomCrdnts.value = ''; //----------------------- очистка поля ввода пользовательских координат
    optFirstSlctCustomColony.textContent = 'Выбрать'; //- обновление текста первого option селекта пользовательских колоний
    slctCustomColony.disabled = false; //---------------- включение селекта пользовательских колоний
  } else { //-------------------------------------------- иначе (если поле ввода имени пользовательской колонии пустое), то
    let code = //---------------------------------------- текст информационного окна
      `<p>Введите название для своей колонии!</p>`
    dWkey = 'information'; //- обновление ключа для объекта типов информационного окна
    showWarning(code); //----- запуск функции показа информационного окна
  }
}

function firstCustomColonyShowWarning() {  //- функция показа предупреждения о сохранении колоний в хранилище браузера
  let code = //------------------------------- текст информационного окна
    `<p>Внимание, координаты колоний сохраняются только в Вашем браузере и могут удалиться при очистке истории или не сохраниться в режиме инкогнито.<br/ >
    Если вам важно сохранить свои координаты, нажмите кнопку "Показать" в разделе "Координаты колоний на карте" и сохраните их где-либо,
    затем можете восстановить свои колонии, введя координаты в поле ввода для координат и сохранить их для текущей сессии</p>`
  dWkey = 'firstCustomColony'; //- обновление ключа для объекта типов информационного окна
  showWarning(code); //----------- запуск функции показа информационного окна
}

//Добавление пользовательских колоний в селект при загрузке
const optFirstSlctCustomColony = document.querySelector('#slctCustomColony option[value="0"]'); //- первый option селекта пользовательских колоний

window.addEventListener('load', addCustomColonyToSelect); //- при загрузке окна: добавление пользовательских колоний в селекты

function addCustomColonyToSelect() { //---------------- функция добавления пользовательских колоний в селект пользовательских колоний
  if (localStorage.length !== 0) { //------------------ если локальное хранилище не пусто (длина не равна 0), то
    for (let i = 0; i < localStorage.length; i++) { //- цикл перебора данных локального хранилища
      //добавление html-кода со значением ключа локального хранилища перед закрывающим тегом селекта
      slctCustomColony.insertAdjacentHTML('beforeend', `<option value="${localStorage.key(i)}">${localStorage.key(i)}</option>`);
    }
  } else { //------------------------------------------------------------- иначе (если локальное хранилище пусто (длина равна 0), то)
    optFirstSlctCustomColony.textContent = 'Здесь будут ваши колонии'; //- обновление текста первого option селекта пользовательских колоний
    slctCustomColony.disabled = true; //---------------------------------- выключение селекта пользовательских колоний
  }
}

//Вывод пользовательских колоний на карту

slctCustomColony.addEventListener('change', e => { //------- при изменении селекта пользовательских колоний
  strCrdnts = localStorage.getItem(e.target.value); //------ присвоение переменной строки координат значения из хранилища соответствующего ключа
  strToArr(); //-------------------------------------------- запуск функции преобразования строки координат в массив координат
  drawPC(); //---------------------------------------------- запуск функции отрисовки канвас предпросмотра
  //drawShadow(); //---------------------------------------- запуск функции отрисовки тени колонии
  slctCustomColony.blur(); //------------------------------- добавление нефокусировки к селекту (разрешение проблемы смены колоний из-за нажатия клавиш)
  nameColony.textContent = e.target.value; //--------------- обновление текста названия выбранной колонии
  optFirstSlctCustomColony.textContent = e.target.value; //- обновление текста первого option селекта пользовательских колоний
  btnDelColony.disabled = false; //------------------------- включение кнопки удаления пользовательской колонии
});

//Удаление пользовательской колонии
const btnDelColony = document.querySelector('#btnDelColony'); //- кнопка удаления пользовательской колонии
btnDelColony.disabled = true; //--------------------------------- выключение кнопки удаления пользовательской колонии

btnDelColony.addEventListener('click', () => { //----------------- при нажатии: запуск выбора для удаление пользовательской колонии
  if (localStorage.getItem(nameColony.textContent) !== null) { //- если ключ локального хранилища с именем колонии не возвращает null, то
    let code = //------------------------------------------------- текст информационного окна
      `<p>Удалить колонию под названием "${nameColony.textContent}"?</p>`
    dWkey = 'delCustomColony'; //- обновление ключа для объекта типов информационного окна
    showWarning(code); //--------- запуск функции показа информационного окна
  }
});

function delCustomColony() { //---------------------------------------------------------------------- функция удаления пользовательской колонии
  localStorage.removeItem(nameColony.textContent); //------------------------------------------------ удаление колонии из локального хранилища с выбранным именем ключа
  document.querySelector(`#slctCustomColony option[value="${nameColony.textContent}"]`).remove(); //- удаление элемента option селекта имен колоний
  clearPC(); //-------------------------------------------------------------------------------------- запуск функции очистки канвас предпросмотра
  drawCells(); //------------------------------------------------------------------------------------ запуск функции отрисовки клеток
}

//Показ строки координат колонии и сохранение строки координат в буфер обмена
const btnShowStr = document.querySelector('#btnShowStr'); //------------- кнопка показа строки координат
const btnSaveClipboard = document.querySelector('#btnSaveClipboard'); //- кнопка копирования строки координат в буфер обмена
const textStr = document.querySelector('#textStr'); //------------------- текст строки координат
const lengthArr = document.querySelector('#lengthArr'); //--------------- текст количества координат
const lengthStr = document.querySelector('#lengthStr'); //--------------- текст длины строки координат

btnShowStr.addEventListener('click', () => { //-------------------------- при нажатии: обновление строки координат
  resetColony() //------------------------------------------------------- запуск функции сброса отрисовки колонии на канвас
  arrToStr(); //--------------------------------------------------------- запуск функции преобразования координат
  if (strCrdnts !== '') { //--------------------------------------------- если строка координат не пуста, то
    btnSaveClipboard.disabled = false; //-------------------------------- включение кнопки копирования строки координат в буфер обмена
    lengthArr.textContent = `Количество клеток: ${arrCrdnts.length}`; //- текст количества координат
  } else { //------------------------------------------------------------ иначе (если строка координат пуста, то)
    btnSaveClipboard.disabled = true; //--------------------------------- отключение кнопки копирования строки координат в буфер обмена
    lengthArr.textContent = `Количество клеток: 0`; //------------------- текст количества координат
    let code = `<p>Карта пуста, создайте свою колонию!</p>` //----------- текст информационного окна
    dWkey = 'information'; //-------------------------------------------- обновление ключа для объекта типов информационного окна
    showWarning(code); //------------------------------------------------ запуск функции показа информационного окна
  }
  textStr.textContent = strCrdnts; //----------------------------- текст строки координат принимает строку переменной
  lengthStr.textContent = `Длина строки: ${strCrdnts.length}`; //- текст длины строки координат
  arrCrdnts = []; //---------------------------------------------- очистка массива координат
});

btnSaveClipboard.addEventListener('click', () => {
  navigator.clipboard.writeText(strCrdnts)
    .then(() => {
      let code = `<p>Координаты скопированы в буфер обмена!</p>` //- текст информационного окна
      dWkey = 'information'; //------------------------------------- обновление ключа для объекта типов информационного окна
      showWarning(code); //----------------------------------------- запуск функции показа информационного окна
    })
    .catch(() => {
      let text = //- текст информационного окна
        `<p><string>Координаты НЕ скопировались в буфер обмена!!!</string></p>
        <p>Выделите координаты вручную и скопируйте, нажав на правую кнопку мыши и выбрав "копировать", или нажмите "Ctrl + C" на клавиатуре.</p>`
      dWkey = 'information'; //- обновление ключа для объекта типов информационного окна
      showWarning(text); //----- запуск функции показа информационного окна
    });
});

//****************************************************************************************************************************************
//БЛОК ИНФОРМАЦИОННОГО ОКНА

const dataWarning = { //------------- объект для отображения информационного окна
  inputSizeMore500: 'noOk', //------- ввод размера мира более 500 клеток (одноразовая информация)
  inputSizeLess1: 'noOk', //--------- ввод размера мира менее 1 клетки (одноразовая информация)
  inputSizeFrac: 'noOk', //---------- ввод размера мира дробным числом (одноразовая информация)
  bigWorld: 'noOk', //--------------- генерация большого мира: более 100 000 клеток (одноразовая информация)
  firstCustomColony: 'noOk', //------ сохранение первой колонии (одноразовая информация)
  delCustomColony: 'yesOrNo', //----- удаление пользовательской колонии (многоразовый выбор)
  rewriteCustomColony: 'yesOrNo', //- перезапись пользовательской колонии (многоразовый выбор)
  bigColony: 'yesOrNo', //----------- увеличение мира под размер большой колонии (многоразовый выбор)
  information: 'info', //------------ различная многоразовая информация
}

const btnOk = document.querySelector('#ok'); //--- кнопка ОК информационного окна
const btnYes = document.querySelector('#yes'); //- кнопка ДА информационного окна
const btnNo = document.querySelector('#no'); //--- кнопка НЕТ информационного окна

let dWkey = ''; //- переменная для ключей объекта информационного окна

btnOk.addEventListener('click', () => { //- при нажатии на кнопку: запуск функций в зависимости от ключа объекта информационного окна
  if (dataWarning[dWkey] === 'noOk') { //-- если ключ объекта информационного окна содержит 'noOk', то
    dataWarning[dWkey] = 'Ok' //----------- ключ объекта информационного окна присваивает 'Ok'
  }
  hideWarning(); //- запуск функции скрытия информационного окна
});

btnNo.addEventListener('click', () => { //- при нажатии на кнопку: запуск функций в зависимости от ключа объекта информационного окна
  if (dWkey === 'bigColony') { //---------- если ключ равен увеличению мира под размер большой колонии, то
    resetColony(); //---------------------- запуск функции сброса отрисовки колонии на канвас
  }
  hideWarning(); //- запуск функции скрытия информационного окна
});

btnYes.addEventListener('click', () => { //- при нажатии на кнопку: запуск функций в зависимости от ключа объекта информационного окна

  if (dWkey === 'delCustomColony') { //- если ключ равен удалению пользовательской колонии, то
    delCustomColony(); //--------------- запуск функции удаления пользовательской колонии
    hideWarning(); //------------------- запуск функции скрытия информационного окна

  } else if (dWkey === 'rewriteCustomColony') { //------------ иначе если ключ равен перезаписи пользовательской колонии, то
    if (dataWarning.firstCustomColony === "noOk") { //-------- если сохранение первой колонии сожержит 'noOk', то
      firstCustomColonyShowWarning(); //---------------------- запуск функции показа предупреждения о сохранении колоний в хранилище браузера
    } else { //----------------------------------------------- иначе (если сохранение первой колонии сожержит 'Ok', то)
      hideWarning(); //--------------------------------------- запуск функции скрытия информационного окна
    }
    localStorage.setItem(inptCustomName.value, strCrdnts); //- добавление строки координат пользовательской колонии в хранилище (перезапись)
    inptCustomName.value = ''; //----------------------------- очистка поля ввода

  } else if (dWkey === 'bigColony') { //------ иначе если ключ равен увеличению мира под размер большой колонии, то
    sizeWorldForBigColony(); //--------------- запуск функции увеличения размера мира под размер колонии
    newWorld(); //---------------------------- запуск функции изменения размеров мира
    if (cW * cH > 100000) { //---------------- если произведение количества ячеек шириы и высоты более 100 000, то
      bigWorldShowWarning(); //--------------- запуск функции показа предупреждения о большом мире
      if (dataWarning.bigWorld === 'Ok') { //- если генерация большого мира содержит 'Ok', то
        hideWarning(); //--------------------- запуск функции скрытия информационного окна
      }
    } else { //------------------------------- иначе (если произведение количества ячеек шириы и высоты меньше или равно 100 000, то)
      hideWarning(); //----------------------- запуск функции скрытия информационного окна
    }
  }
});

const warningPanel = document.querySelector('#warningPanel'); //- панель информационного окна
const warningText = document.querySelector('#warningText'); //--- текст панели информационного окна

function hideWarning() { //-------------- функция скрытия информационного окна
  warningPanel.classList.add('none'); //- добавление класса 'none' для информационного окна
  dWkey = ''; //------------------------- сброс значения ключа объекта информационного окна
}

function showWarning(a) { //------------------------ функция показа информационного окна
  warningPanel.classList.remove('none'); //--------- удаление класса 'none' для информационного окна
  warningText.innerHTML = a; //--------------------- присваивание тексту информационного окна аргумента a
  if (dataWarning[dWkey] === 'noOk' || //----------- если ключ объекта информационного окна содержит 'noOk' ИЛИ
    dataWarning[dWkey] === 'info') { //------------- ключ объекта информационного окна содержит 'info', то
    btnYes.classList.add('none'); //---------------- добавление класса 'none' для кнопки ДА информационного окна
    btnNo.classList.add('none'); //----------------- добавление класса 'none' для кнопки НЕТ информационного окна
    btnOk.classList.remove('none'); //-------------- удаление класса 'none' для кнопки ОК информационного окна
  } else if (dataWarning[dWkey] === 'yesOrNo') { //- иначе если ключ объекта информационного окна содержит yesOrNo, то
    btnYes.classList.remove('none'); //------------- удаление класса 'none' для кнопки ДА информационного окна
    btnNo.classList.remove('none'); //-------------- удаление класса 'none' для кнопки НЕТ информационного окна
    btnOk.classList.add('none'); //----------------- добавление класса 'none' для кнопки ОК информационного окна
  }
}

function sizeWorldForBigColony() { //------------------------------------------ функция увеличения размера мира под размер колонии
  cW = worldNewSize; //-------------------------------------------------------- значение ширины мира присваивает новый размер мира
  cH = worldNewSize; //-------------------------------------------------------- значение высоты мира присваивает новый размер мира
  inptCnW.value = worldNewSize; //--------------------------------------------- селект количества ячеек ширины присваивает новый размер мира
  inptCnH.value = worldNewSize; //--------------------------------------------- селект количества ячеек высоты присваивает новый размер мира
  if ((cW / Math.floor(wrapperCanvas.clientWidth * 0.99 / cellSize) > 4) || //- если ширина мира деленная на размер окна по ширине деленный на размер клетки больше 4 ИЛИ
    (cH / Math.floor(wrapperCanvas.clientHeight * 0.99 / cellSize)) > 4) { //-- высота мира деленная на размер окна по высоте деленный на размер клетки больше 4, то
    scaleSmaller(); //--------------------------------------------------------- запуск функции уменьшения масштаба х3
    scaleSmaller();
    scaleSmaller();
  } else if ((cW / Math.floor(wrapperCanvas.clientWidth * 0.99 / cellSize) > 2) || //- иначе (аналогично для меньшей разницы)
    (cH / Math.floor(wrapperCanvas.clientHeight * 0.99 / cellSize)) > 2) {
    scaleSmaller();
    scaleSmaller();
  } else if (((cW / Math.floor(wrapperCanvas.clientWidth * 0.99 / cellSize) > 1) ||
    (cH / Math.floor(wrapperCanvas.clientHeight * 0.99 / cellSize)) > 1)) {
    scaleSmaller();
  }
  if ((Math.floor(wrapperCanvas.clientWidth * 0.99 / cellSize) *
    (Math.floor(wrapperCanvas.clientHeight * 0.99 / cellSize))) < 100000) { //- если произведение ширины и высоты нового размера мира меньше 100 000, то
    inWindow(); //------------------------------------------------------------- запуск функции вписывания мира в окно просмотра
  }
}

//****************************************************************************************************************************************
//ПРОЧИЕ ФУНКЦИИ

//Сброс значений селектов
window.addEventListener('click', () => { //- при клике где либо в окне
  resetSelects(); //------------------------ запуск функции сброса значений селектов
});
function resetSelects() { //------------------------------------------------------- функция сброса значений селектов
  const slctsDefaultColony = document.querySelectorAll('#defaultColony select') //- все селекты готовых колоний
  slctsDefaultColony.forEach(e => { //--------------------------------------------- для каждого селекта готовых колоний
    e.value = 0; //---------------------------------------------------------------- значение присваивает 0
  });
  slctCustomColony.value = 0; //- сброс значения для селекта пользовательских колоний
}

//Управление с клавиатуры
let inputFocus = false; //--------------------------------------------- переменная фокуса полей ввода данных (для отключения управления с клавиатуры)
inptCnW.addEventListener('focus', () => inputFocus = true); //--------- при фокусировке на селект количества ячеек ширины
inptCnW.addEventListener('blur', () => inputFocus = false); //--------- при нефокусировке на селект количества ячеек ширины
inptCnH.addEventListener('focus', () => inputFocus = true); //--------- при фокусировке на селект количества ячеек высоты
inptCnH.addEventListener('blur', () => inputFocus = false); //--------- при нефокусировке на селект количества ячеек высоты
inptCustomName.addEventListener('focus', () => inputFocus = true); //-- при фокусировке на поле ввода имени пользовательской колонии
inptCustomName.addEventListener('blur', () => inputFocus = false); //-- при нефокусировке на поле ввода имени пользовательской колонии
inpCustomCrdnts.addEventListener('focus', () => inputFocus = true); //- при фокусировке на поле ввода пользовательских координат
inpCustomCrdnts.addEventListener('blur', () => inputFocus = false); //- при нефокусировке на поле ввода пользовательских координат

window.addEventListener('keyup', e => { //--------- при отжатии клавиши
  if (!inputFocus) { //---------------------------- если переменная фокуса false, то
    switch (e.code) { //--------------------------- если отжата кнопка с кодом case, то запуск соответствующей функции
      case 'KeyQ': horizReflection(); drawPC(); //- запуск функций: отражения колонии по горизонтали, отрисовки канвас предпросмотра
        break;
      case 'KeyW': vertReflection(); drawPC(); //-- запуск функций: отражения колонии по вертикали, отрисовки канвас предпросмотра
        break;
      case 'KeyE': leftTurn(); drawPC(); //-------- запуск функций: поворота колонии влево на 90 градусов, отрисовки канвас предпросмотра
        break;
      case 'KeyR': rightTurn(); drawPC(); //------- запуск функций: поворота колонии вправо на 90 градусов, отрисовки канвас предпросмотра
        break;
      case 'KeyT': rotate180deg(); drawPC(); //---- запуск функций: поворота колонии на 180 градусов, отрисовки канвас предпросмотра
        break;
      case 'KeyA': startStopGame(); //------------- запуск функции старт/стоп
        break;
      case 'KeyD': limitedWorld(); //-------------- запуск функции смены режима границ мира
        break;
      case 'KeyF': trackModeFunc(); //------------- запуск функции смены режима следов
        break;
      case 'KeyG': inWindow(); //------------------ запуск функции вписывания мира в окно просмотра
        break;
      case 'NumpadAdd': scaleLarger(); //---------- запуск функции увелисения масштаба
        break;
      case 'Equal': scaleLarger(); //-------------- запуск функции увелисения масштаба
        break;
      case 'NumpadSubtract': scaleSmaller(); //---- запуск функции уменьшения масштаба
        break;
      case 'Minus': scaleSmaller(); //------------- запуск функции уменьшения масштаба
        break;
      case 'Delete': clearGame(); //--------------- запуск функции очистки мира
        break;
      case 'NumpadDecimal': clearGame(); //-------- запуск функции очистки мира
        break;
    }
  }
});

window.addEventListener('keydown', e => { //- при нажатии на клавишу
  if (!inputFocus) { //---------------------- если переменная фокуса false, то
    switch (e.code) { //--------------------- если нажата кнопка с кодом case, то
      case 'KeyS': oneStepGame(); //--------- запуск функции одного шага игры
        break;
    }
  }
});

//****************************************************************************************************************************************
//БЛОК ДЛЯ ОФОРМЛЕНИЯ СТРАНИЦЫ

//Открытие/закрытие выпадающих-сменяющихся панелей
const btnsDropDown = document.querySelectorAll('.btn_tab_drop-down_toggle'); //----- кнопки для выпадающих-сменяющихся панелей
const divsPanelsDropDown = document.querySelectorAll('.panel_drop-down_toggle'); //- выпадающие-сменяющиеся панели div
const dropDownToggleBox = document.querySelector('#dropDownToggleBox'); //---------- секция выпадающих-сменяющихся панелей

for (let i = 0; i < btnsDropDown.length; i++) { //------- цикл перебора кнопок для выпадающих-сменябщихся панелей
  btnsDropDown[i].addEventListener('click', () => { //--- при нажатии на кнопку: открытие/закрытие выпадающих-сменябщихся панелей
    if (btnsDropDown[i].classList.contains('open')) { //- если кнопка содержит класс 'open', то (закрытие соответствующей панели)
      btnsDropDown[i].classList.remove('open'); //------- удаление класса 'open' для кнопки
      btnsDropDown[i].classList.add('close'); //--------- добавление класса 'close' для кнопки
      divsPanelsDropDown[i].classList.add('none'); //---- добавление класса 'none' для панели div
      dropDownToggleBox.classList.add('none'); //-------- добавление класса 'none' для секции выпадающих-сменябщихся панелей
      for (let i = 0; i < btnsDropDown.length; i++) { //- цикл перебора кнопок
        btnsDropDown[i].classList.add('all-close'); //--- добавление класса 'all-close' для всех кнопок, так как все закрыты
      }
    } else { //------------------------------------------- иначе (если кнопка не содежит класс 'open', то)
      for (let i = 0; i < btnsDropDown.length; i++) { //-- цикл перебора кнопок для выпадающих-сменябщихся панелей (закрытие всех панелей)
        btnsDropDown[i].classList.remove('open'); //------ удаление класса 'open' для кнопки
        btnsDropDown[i].classList.add('close'); //-------- добавление класса 'close' для кнопки
        divsPanelsDropDown[i].classList.add('none'); //--- добавление класса 'none' для панели div
        btnsDropDown[i].classList.remove('all-close'); //- удаление класса 'all-close' для всех кнопок, так как одна будет открыта
      }
      //Открытие соответствующей панели
      btnsDropDown[i].classList.remove('close'); //------ удаление класса close для кнопки
      btnsDropDown[i].classList.add('open'); //---------- добавление класса 'open' для кнопки
      divsPanelsDropDown[i].classList.remove('none'); //- удаление класса 'none' для панели div
      dropDownToggleBox.classList.remove('none'); //----- удаление класса 'none' для секции выпадающих-сменябщихся панелей
    }
  });
}

function hideDropDownToggleBox() { //---------------- функция сворачивания выпадающих-сменяющихся панелей
  for (let i = 0; i < btnsDropDown.length; i++) { //- цикл перебора кнопок для выпадающих-сменяющихся панелей
    btnsDropDown[i].classList.remove('open'); //----- удаление класса 'open' для кнопки
    btnsDropDown[i].classList.add('close'); //------- добавление класса 'close' для кнопки
    btnsDropDown[i].classList.add('all-close'); //--- добавление класса 'all-close' для кнопки
    divsPanelsDropDown[i].classList.add('none'); //-- добавление класса 'none' для панели
    dropDownToggleBox.classList.add('none'); //------ добавление класса 'none' для секции выпадающих-сменяющихся панелей
  }
}

//выпадающие субпанели вкладки колонии
const btnsTabDropDownColony = document.querySelectorAll('.btn_tab_drop-down_colony'); //- кнопки открытия/скрытия субпанелей вкладки колонии
const panelsDropDownColony = document.querySelectorAll('.panel_drop-down_colony'); //---- выпадающие субпанели вкладки колонии

for (let i = 0; i < btnsTabDropDownColony.length; i++) { //------- цикл перебора кнопок для выпадающих панелей
  btnsTabDropDownColony[i].addEventListener('click', () => { //--- при нажатии на кнопку: открытие/закрытие выпадающих панелей
    if (btnsTabDropDownColony[i].classList.contains('open')) { //- если кнопка содержит класс 'open', то (закрытие соответствующей панели)
      btnsTabDropDownColony[i].classList.remove('open'); //------- удаление класса 'open' для кнопки
      btnsTabDropDownColony[i].classList.add('close'); //--------- добавление класса 'close' для кнопки
      panelsDropDownColony[i].classList.add('none'); //------ добавление класса 'none' для панели section
    } else { //--------------------------------------------- иначе (если кнопка не содежит класс 'open', то)
      btnsTabDropDownColony[i].classList.remove('close'); //------ удаление класса close для кнопки
      btnsTabDropDownColony[i].classList.add('open'); //---------- добавление класса 'open' для кнопки
      panelsDropDownColony[i].classList.remove('none'); //--- удаление класса 'none' для панели section
    }
  });
}

//выпадающие субпанели вкладки готовых колонии
function dropDownFunc() { //- функция функционирования открытия закрытия выпадающих субпанаелей вкладки готовых колоний

  const btnsTabDropDC = document.querySelectorAll('.btn_tab_drop-down_default-colony'); //- кнопки открытия/скрытия панелей
  const panelDropDownDC = document.querySelectorAll('.panel_drop-down_default-colony'); //- выпадающие субпанели вкладки готовых колонии

  for (let i = 0; i < btnsTabDropDC.length; i++) { //------- цикл перебора кнопок для выпадающих панелей
    btnsTabDropDC[i].addEventListener('click', () => { //--- при нажатии на кнопку: открытие/закрытие выпадающих панелей
      if (btnsTabDropDC[i].classList.contains('open')) { //- если кнопка содержит класс 'open', то (закрытие соответствующей панели)
        btnsTabDropDC[i].classList.remove('open'); //------- удаление класса 'open' для кнопки
        btnsTabDropDC[i].classList.add('close'); //--------- добавление класса 'close' для кнопки
        panelDropDownDC[i].classList.add('none'); //-------- добавление класса 'none' для панели section
      } else { //------------------------------------------- иначе (если кнопка не содежит класс 'open', то)
        btnsTabDropDC[i].classList.remove('close'); //------ удаление класса close для кнопки
        btnsTabDropDC[i].classList.add('open'); //---------- добавление класса 'open' для кнопки
        panelDropDownDC[i].classList.remove('none'); //----- удаление класса 'none' для панели section
      }
    });
  }
}

//сменяющиеся панели
const subTabBtns = document.querySelectorAll('.btn_tab_toggle'); //- кнопки для субпанелей колоний
const subPanels = document.querySelectorAll('.panel_toggle'); //---- субпанели колоний

for (let i = 0; i < subTabBtns.length; i++) { //----- цикл перебора кнопок для субпанелей
  subTabBtns[i].addEventListener('click', () => { //- при нажатии на кнопку: вывод соответствкющей субпанели
    for (let i = 0; i < subTabBtns.length; i++) { //- цикл преребора кнопок для субпанелей (закрытие всех субпанелей)
      subTabBtns[i].classList.remove('open'); //----- удаление класса open для кнопки
      subTabBtns[i].classList.add('close'); //------- добавление класса 'close' для кнопки
      subPanels[i].classList.add('none'); //--------- добавление класса 'none' для субпанели
    }
    //открытие соответствующей субпанели
    subTabBtns[i].classList.remove('close'); //- удаление класса 'close' для кнопки
    subTabBtns[i].classList.add('open'); //----- добавление класса 'open' для кнопки
    subPanels[i].classList.remove('none'); //--- удаление класса 'none' для субпанели
  });
}

//режим широкого вида вкладки колоний
const btnLandscapeMode = document.querySelector('#btnLandscapeMode'); //- кнопка изменения видов вкладки колоний

btnLandscapeMode.addEventListener('click', () => { //---------- при нажатии: смена видов вкладки
  if (document.body.clientWidth > 630) { //-------------------- если ширина элемента body больше 630
    if (document.body.classList.contains('landscape')) { //---- если элемент body содержит класс 'landscape', то
      document.body.classList.remove('landscape'); //---------- удаление класса 'landscape' для элемента body
      btnLandscapeMode.textContent = 'Широкий вид вкладки'; //- обновление текста кнопки изменения видов вкладки
      btnsTabDropDownColony.forEach(e => { //------------------ для каждой кнопки открытия/скрытия субпанелей вкладки колонии
        e.classList.remove('open'); //------------------------- удаление класса 'open'
        e.classList.add('close'); //--------------------------- добавление класса 'close'
      });
      panelsDropDownColony.forEach(e => { //- для каждой выпадающей субпанели вкладки колонии
        e.classList.add('none'); //---------- добавление класса 'none'
      });
    } else { //---------------------------------------------- иначе (если элемент body не содержит класс 'landscape', то)
      document.body.classList.add('landscape'); //----------- добавление класса 'landscape' для элемента body
      btnLandscapeMode.textContent = 'Узкий вид вкладки'; //- обновление текста кнопки изменения видов вкладки
      btnsTabDropDownColony.forEach(e => { //---------------- для каждой кнопки открытия/скрытия субпанелей вкладки колонии
        e.classList.remove('close'); //---------------------- удаление класса 'close'
        e.classList.add('open'); //-------------------------- добавление класса 'open'
      });
      panelsDropDownColony.forEach(e => { //- для каждой выпадающей субпанели вкладки колонии
        e.classList.remove('none'); //------- удаление класса 'none'
      });
    }
  } else { //- иначе (если ширина элемента body меньше 630, то)
    //для возможности скрытия вкладки при повороте экрана
    if (document.body.classList.contains('landscape')) { //---- если элемент body содержит класс 'landscape', то 
      document.body.classList.remove('landscape'); //---------- удаление класса 'landscape' для элемента body
      btnLandscapeMode.textContent = 'Широкий вид вкладки'; //- обновление текста кнопки изменения видов вкладки
      btnsTabDropDownColony.forEach(e => { //------------------ для каждой кнопки открытия/скрытия субпанелей вкладки колонии
        e.classList.remove('open'); //------------------------- удаление класса 'open'
        e.classList.add('close'); //--------------------------- добавление класса 'close'
      });
      panelsDropDownColony.forEach(e => { //- для каждой выпадающей субпанели вкладки колонии
        e.classList.add('none'); //---------- добавление класса 'none'
      });
    } else { //------------------------------------------------ иначе (если элемент body не содержит класс 'landscape', то)
      dWkey = 'information'; //-------------------------------- обновление ключа для объекта типов информационного окна
      let code = ''; //---------------------------------------- переменная текста информационного окна
      if (screen.orientation.type === 'portrait-primary') { //- если ориентация экрана книжная, то
        code = //---------------------------------------------- обновление текста информационного окна
          `<p>Ширина экрана не позволяет показать широкий вид вкладки,
          попробуйте изменить положение экрана на альбомный</p>`
      } else { //- иначе (если ориентация экрана альбомная, то)
        code = //- обновление текста информационного окна
          `<p>К сожалению, ширина экрана не позволяет показать широкий вид вкладки</p>`
      }
      showWarning(code); //- запуск функции показа информационного окна
    }
  }

});

const btnDropDownToggleSettings = document.querySelector('#btnDropDownToggleSettings'); //- кнопка выпадающе-сменяющейся панели настроек

btnDropDownToggleSettings.addEventListener('click', () => { //- при нажатии: сброс широкого вида вкладки
  if (document.body.classList.contains('landscape')) { //------ если элемент body содержит класс 'landscape', то
    document.body.classList.remove('landscape'); //------------ удаление класса 'landscape' для элемента body
    btnLandscapeMode.textContent = 'Широкий вид вкладки'; //--- обновление текста кнопки изменения видов вкладки
    btnsTabDropDownColony.forEach(e => { //-------------------- для каждой кнопки открытия/скрытия субпанелей вкладки колонии
      e.classList.remove('open'); //--------------------------- удаление класса 'open'
      e.classList.add('close'); //----------------------------- добавление класса 'close'
    });
    panelsDropDownColony.forEach(e => { //- для каждой выпадающей субпанели вкладки колонии
      e.classList.add('none'); //---------- добавление класса 'none'
    });
  }
});